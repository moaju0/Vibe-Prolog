# Simple Prolog Interpreter Architecture & Usage

A minimal yet capable Prolog interpreter in Python. This document combines
usage guides, architecture notes, testing guidance, and contributor-focused
context so you can reason about the system in one place.

## Project Structure

```
vibeprolog/
├── interpreter.py          # High-level PrologInterpreter interface
├── engine.py               # Core execution engine (~200 lines)
├── parser.py               # Prolog syntax parser
├── unification.py          # Unification algorithm
├── builtins/               # Built-in predicate implementations
│   ├── arithmetic.py
│   ├── control.py
│   ├── ...
└── utils/                  # Utility functions
    ├── term_utils.py
    ├── list_utils.py
    └── variable_utils.py
```

## Features & ISO Coverage

See `docs/FEATURES.md` for the full checklist of ISO predicates and syntax features.
At the moment 102 entries in that matrix are marked ✅, covering ISO-style
parsing, unification, backtracking execution, and a broad set of built-ins. Use
that document to understand missing directives, error terms, and parser gaps.

## Usage

### Running the Demo

```bash
uv run vibeprolog.py
```

### Running Tests

```bash
uv run pytest        # all tests
uv run pytest -v     # verbose
uv run pytest tests/test_builtins.py
uv run pytest tests/test_parser.py
```

See the "Tooling & Tests" section for additional harness info.

### Using as a Library

```python
from vibeprolog import PrologInterpreter

prolog = PrologInterpreter()
prolog.consult_string("""
    parent(tom, bob).
    parent(tom, liz).
    grandparent(X, Z) :- parent(X, Y), parent(Y, Z).
""")

results = prolog.query("grandparent(tom, Who)")
for result in results:
    print(f"Tom's grandchild: {result['Who']}")

result = prolog.query_once("parent(tom, X)")
if result:
    print(f"Tom's child: {result['X']}")

if prolog.has_solution("parent(tom, bob)"):
    print("Tom is bob's parent")
```

### Loading from Files

```python
prolog = PrologInterpreter()
prolog.consult("my_rules.pl")
results = prolog.query("my_query(X)")
```

## Architecture Overview

The interpreter consists of four main components:

1. **Parser** (`vibeprolog/parser.py`) - Uses Lark to parse Prolog syntax with full
    operator precedence, multi-base numeric literals (including base-qualified
    numbers like `16'ff`), quoted atoms/strings, escapes, and ISO character code
    forms (except for a handful of noted edge cases).
2. **Unification** (`vibeprolog/unification.py`) - Robinson-style unification with
   occurs-check by default so cyclic structures are prevented.
3. **Engine** (`vibeprolog/engine.py`) - Backtracking search with built-in
   predicates, cut semantics, dynamic predicate assertion/retraction, first-argument
   indexing for efficient clause lookup, and the dispatcher that resolves
   functor/arity to handlers.
4. **Interpreter** (`vibeprolog/interpreter.py`) - Public API for loading and
   querying programs, plus helpers for consulting strings/files and capturing
   output streams.

## First-Argument Indexing

The engine implements first-argument indexing to optimize clause lookup performance for large knowledge bases. Instead of scanning all clauses linearly during goal resolution, the engine maintains an index mapping first argument patterns to relevant clauses, enabling O(1) lookups for many common query patterns.

### How It Works

The index maps first argument patterns to clause lists:

- **Ground atoms**: Direct lookup by atom value (`person(alice, X)` → key = `alice`)
- **Ground numbers**: Direct lookup by number value (`age(25, X)` → key = `25`)
- **Empty list**: Direct lookup for `[]` (`list([], X)` → key = `[]`)
- **Compound terms**: Lookup by functor of first argument (`tree(node(X), Y)` → key = `node/?`)
- **Variables**: No indexing - falls back to scanning all clauses (`person(X, Y)`)

### Data Structure

_first_arg_index = {
    # Values are lists of integer indices into the engine's main clause list
    # (i.e., clause indices, not clause objects)
    ('person', 2, 'atom', 'alice'): [0, 5],
    ('person', 2, 'atom', 'bob'): [8],
    ('age', 2, 'number', 25): [12],
    # ...
}

_variable_first_arg_clauses = {
    # Stores indices for clauses with a variable as the first argument
    # (i.e., clause indices into the engine's main clause list)
    ('person', 2): [15, 21],
    # ...
}

### Performance Impact

- **Indexed queries** (ground first arg): O(1) lookup instead of O(n) scan
- **Unindexed queries** (variable first arg): O(n) scan (same as before)
- **Dynamic operations**: `asserta/assertz/retract/abolish` maintain index consistency

### Implementation Details

- Index keys are generated by `_make_index_key()` method
- Clauses are indexed during addition via `_index_clause()`
- Retrieval uses `_get_indexed_clauses()` for efficient filtering
- Dynamic database operations update the index automatically

## Tabling at a Glance

Tabling allows the engine to memoize predicate calls so repeated queries reuse
previously discovered substitutions. When a `:- table` directive is seen during
consult, the interpreter records the functor/arity pair. During execution the
engine computes a variant-based signature for the call (ignoring variable
names) and stores the resulting substitutions. Later calls with the same
structure return cached answers directly, avoiding redundant recomputation.

This implementation focuses on simple variant tabling:

- Predicate indicators: `:- table foo/1, bar/2.`
- Call signatures normalize variables positionally so variants map to the same
  cache entry.
- Answers are cached per predicate per signature and replayed on subsequent
  invocations.

## Built-in Registry

Built-ins live under `vibeprolog/builtins/` and register themselves via
`prolog.builtins.register_builtin`. Each module exposes a static `register`
method so the engine can populate its registry at startup. Handlers use the
signature `(args, subst, engine)` and can yield multiple substitutions for
non-deterministic predicates.

### Adding a New Built-in Predicate

1. **Choose the appropriate module** in `vibeprolog/builtins/`:
   - Arithmetic operations → `arithmetic.py`
   - List operations → `list_ops.py`
   - Type tests → `type_tests.py`
   - Control flow → `control.py`
   - Database → `database.py`
   - I/O → `io.py`
   - Term manipulation → `term_manipulation.py`
   - All-solutions → `all_solutions.py`
   - Exceptions → `exceptions.py`
   - Reflection → `reflection.py`
   - Higher-order → `higher_order.py`

2. **Add a static method** to the module's class:

   ```python
   @staticmethod
   def my_builtin(args: BuiltinArgs, subst: Substitution, engine: EngineContext) -> BuiltinResult:
       """my_builtin/N - Description."""
       # Implementation
   ```

3. **Register in the module's register() method**:

   ```python
   @staticmethod
   def register(registry: BuiltinRegistry, engine_ref=None):
       registry[("my_builtin", N)] = ModuleClass.my_builtin
   ```

4. **Add tests** in `tests/test_*.py`.
5. **Update docs/FEATURES.md** to mark the predicate as implemented.

## Tooling & Tests

- Exercise the system primarily through the Python API (`from vibeprolog import
  PrologInterpreter`) and the pytest suite (800+ tests covering ISO core,
  parser pathologies, and built-in behaviors).
- `PrologInterpreter` exposes `consult/consult_string`, `query`, `query_once`,
  and `has_solution`, plus optional stdout capture so predicates like `write`
  and `format` can be observed while still returning substitutions.
- Built-in predicates are dispatched through the registry in
  `vibeprolog/engine.py`. To add one, register a handler that either yields
  substitutions or returns `None`. Helpers such as `_format_to_string`,
  `_list_to_python` (respects active substitutions), and `_fresh_variable`
  centralize tricky behavior so new built-ins stay consistent.

### Predicate properties and mutability

Predicate properties are tracked at two levels:

- **Global level**: `PrologInterpreter.predicate_properties` tracks built-in predicates
  and provides backward compatibility for global predicate lookups.
- **Module level**: `PrologInterpreter._module_predicate_properties` maps
  `module_name -> {(functor, arity) -> set[str]}` for module-scoped predicate properties.

This allows different modules to define predicates with the same name/arity without
conflict. For example, `library(error)` can export `must_be/2` while `library(clpz)`
defines its own `must_be/2` for internal use.

Property resolution order:
1. Check if predicate is a built-in (global, always accessible)
2. Check module-scoped properties for the current module
3. Fall back to global properties for backward compatibility

`PrologInterpreter._predicate_sources` and `_module_predicate_sources` track which
consult call introduced each predicate so non-multifile predicates cannot be extended
by later files within the same module.

User-defined predicates start as **static**, meaning `asserta/1`, `assertz/1`,
`retract/1`, and `abolish/1` raise `permission_error` unless the predicate was
declared `dynamic/1`. Built-ins are always `static` and `built_in`. Discontiguity
and multifile declarations are validated during consultation to ensure clause
ordering and multi-file composition follow ISO expectations.

## Utility Modules

Shared helpers for the AST live in `vibeprolog/utils/`:

- `term_utils.py`: Formatting, comparison, and sorting helpers for terms.
- `list_utils.py`: Convert between Python and Prolog list forms; match/shape
  lists.
- `variable_utils.py`: Variable collection, copying, and existential stripping.

These modules are imported by `vibeprolog/engine.py` and have focused coverage in
`tests/utils/`.

## DCG (Definite Clause Grammar) Support

DCG rules are syntactic sugar for Prolog clauses that manipulate difference lists.
The `vibeprolog/dcg.py` module handles the expansion of DCG syntax into regular Prolog.

### DCG Expansion Process

1. **Parser**: DCG rules `Head --> Body` are parsed as special clause types
2. **Expansion**: During consultation, DCG clauses are expanded using `DCGExpander`
3. **Storage**: Expanded rules are stored as regular Prolog clauses with difference list arguments

### Expansion Rules

- `Head --> Body` becomes `Head(S0, S) :- ExpandedBody`
- Terminals `[X, Y, Z]` → `S0 = [X, Y, Z | S]`
- Non-terminals `foo` → `foo(S0, S)`
- Sequences `a, b` → threaded difference lists: `a(S0, S1), b(S1, S)`
- Alternatives `(a ; b)` → `a(S0, S) ; b(S0, S)`
- Embedded goals `{Goal}` → `S0 = S, Goal` (no list threading)
- Empty `[]` → `S0 = S`
- Cut `!` → preserved as-is

### Built-in Predicates

- `phrase(RuleSet, List)` ≡ `RuleSet(List, [])`
- `phrase(RuleSet, List, Rest)` ≡ `RuleSet(List, Rest)`

DCG rules are expanded at parse time, not runtime, ensuring efficient execution.

## Attributed Variables

Attributed variables provide the foundation for constraint logic programming (CLP) in Vibe-Prolog. They allow metadata (attributes) to be attached to unbound variables, with hooks called when those variables are unified.

### Implementation Architecture

The attributed variable system is implemented across several modules:

1. **Attribute Storage** (`vibeprolog/engine.py`): Attributes are stored in a dictionary (`_attribute_store`) that maps variable names to dictionaries of attributes. Each attribute is keyed by its functor.

2. **Built-in Predicates** (`vibeprolog/builtins/atts.py`): Implements the core predicates:
   - `put_atts/2`: Add or remove attributes from variables
   - `get_atts/2`: Query attributes on variables
   - `attvar/1`: Test if a variable has attributes
   - `term_attvars/2`: Collect all attributed variables in a term
   - `copy_term/3`: Copy term with attributes as goals
   - `del_atts/1`: Delete all attributes from a variable

3. **Unification Integration** (`vibeprolog/unification.py`): The `AttributedUnificationContext` class extends unification to track when attributed variables are unified, enabling the `verify_attributes/3` hook mechanism.

4. **Hook Execution** (`vibeprolog/engine.py`): The `_unify_with_attvar_support` method handles the complete workflow:
   - Perform standard unification while tracking attributed variable unifications
   - Call `verify_attributes/3` for each attributed variable being unified
   - Execute any goals returned by the hook
   - Fail unification if the hook fails or returned goals fail

### Attribute Storage Model

```python
# Engine's attribute store structure
_attribute_store = {
    'X': {'domain': Compound('domain', ([1, 2, 3],)), 'label': Atom('foo')},
    'Y': {'type': Compound('type', (Atom('integer'),))}
}
```

Attributes persist across the lifetime of a query. When a variable is unified with a value, the attributes remain in the store but the `verify_attributes/3` hook is triggered to validate the unification.

### The verify_attributes/3 Hook

When an attributed variable is unified with a term:

1. The engine creates a fresh proxy variable with the same attributes
2. Calls `verify_attributes(ProxyVar, Value, Goals)` where:
   - `ProxyVar`: A variable with the original attributes accessible via `get_atts/2`
   - `Value`: The term being unified with the attributed variable
   - `Goals`: Output - list of goals to execute after unification
3. If `verify_attributes/3` fails, the unification fails
4. If it succeeds, the returned goals are executed; if any fail, unification fails

### Usage Example

```prolog
:- use_module(library(atts)).

% Domain constraint: variable can only be unified with values in domain
verify_attributes(Var, Value, []) :-
    get_atts(Var, domain(Domain)),
    member(Value, Domain).

% Using the constraint
?- put_atts(X, +domain([a, b, c])), X = b.
X = b.

?- put_atts(X, +domain([a, b, c])), X = d.
false.
```

### Integration with CLP Libraries

The `library(atts)` module provides the foundation for constraint libraries like CLP(Z) and CLP(B). These libraries use attributed variables to:

- Attach constraint metadata to variables
- Implement constraint propagation through `verify_attributes/3`
- Handle unification of constrained variables

### Residual Goal Projection

The `library($project_atts)` module (`vibeprolog/builtins/project_atts.py`) handles projection of attributed variable constraints into residual goals. This is used for:

1. **`copy_term/3`**: When copying a term with attributed variables, the third argument receives a list of goals that represent the constraints.

2. **Toplevel display**: When a query completes with attributed variables, residual goals show the remaining constraints in human-readable form.

**Key predicates:**

- **`term_residual_goals(Term, Goals)`**: Collects all attributed variables in `Term` and converts their attributes to goal terms. For each attributed variable:
  1. If the defining module exports `attribute_goals//1`, that DCG hook is called
  2. Otherwise, a default `put_atts(Var, +Attr)` goal is generated

- **`project_attributes(QueryVars, AttrVars)`**: Projects constraints from `AttrVars` onto `QueryVars`. For each module with attributes:
  1. If the module exports `project_attributes/2`, it is called for module-specific projection
  2. This allows constraint libraries to hide internal variables from the user

**The `attribute_goals//1` hook:**

Modules define this DCG to describe how their attributes should appear as goals:

```prolog
% In library(freeze)
attribute_goals(Var) -->
    { get_atts(Var, frozen(Goals)),
      put_atts(Var, -frozen(_)) },
    [freeze:freeze(Var, Goals)].
```

**Implementation details:**

- The `$` prefix in `$project_atts` indicates an internal/system module
- Goals are collected by traversing the term for attributed variables using `term_attvars/2`
- The DCG hook mechanism attempts to call `Module:attribute_goals(Var, S0, S)` and extracts goals from the difference list
- If no hook is defined, the raw attribute is wrapped in a `put_atts/2` goal

## Recursion Depth Limits

The engine enforces a maximum recursion depth to prevent Python stack overflow and provide clear error messages for infinite recursion.

### Configuration

```python
# Default limit: 10,000
prolog = PrologInterpreter()

# Custom limit
prolog = PrologInterpreter(max_recursion_depth=1000)
```

### Implementation

The interpreter uses a hybrid approach to support deep recursion:

1. **Python Recursion Limit Increase**: On startup, the engine automatically increases Python's recursion limit from the default (~1000) to 50,000 (if the system allows). This allows the standard recursive resolution algorithm to operate without Python stack overflow.

2. **Logical Depth Tracking**: Independent of Python's stack depth, the engine tracks Prolog logical depth (number of goal resolution steps) and enforces the configurable `max_recursion_depth` limit. This provides clear, meaningful error messages when Prolog logical depth is exceeded.

3. **Tail-Recursive Optimization**: The implementation uses Python's generator-based backtracking, which naturally supports tail recursion patterns efficiently. Tail-recursive predicates (those where the last goal in the body is the recursive call with no further computation) execute without consuming additional Python stack space beyond the baseline.

### Behavior

- Logical depth is tracked across all goal resolution
- When logical depth exceeds `max_depth`, raises `resource_error(recursion_depth_exceeded)`
- Depth counter resets for each top-level query
- Error includes context showing which predicate exceeded limit
- Python recursion limit is automatically increased to support deeper Prolog recursion

### Typical Capabilities

- **Tail-recursive predicates** (e.g., `count_down(0). count_down(N) :- N > 0, N1 is N - 1, count_down(N1).`): Support recursion depths up to the logical limit (default 10,000)
- **Non-tail-recursive predicates** (e.g., `factorial`, `fibonacci` with post-processing): Limited to moderate depths (~100-500) due to Python stack consumption
- **Mutual recursion**: Supported to the same depth as tail recursion
- **Backtracking with recursion**: Full semantics preserved; all solutions found correctly

## Examples

### Family Relationships

```prolog
parent(tom, bob).
parent(bob, ann).

grandparent(X, Z) :- parent(X, Y), parent(Y, Z).
ancestor(X, Y) :- parent(X, Y).
ancestor(X, Y) :- parent(X, Z), ancestor(Z, Y).
```

### List Operations

```prolog
% member/2 is built-in
?- member(2, [1,2,3]).  % True
?- member(X, [a,b,c]).  % X = a ; X = b ; X = c
```

### Logic Puzzles

```prolog
person(alice).
person(bob).

job(alice, doctor).
job(bob, engineer).

% Who has which job?
?- job(Person, doctor).  % Person = alice
```

## Module System

- Each module is represented by a `Module` object stored in `PrologInterpreter.modules`.
- Module declaration uses `:- module(Name, Exports).` and sets the current module context for subsequent clauses during consultation.
- Predicates defined in modules are associated with their defining module; clauses carry a `module` attribute.
- **Predicate namespaces are isolated per module**: Different modules can define predicates with the same name/arity without conflict. For example, if `library(error)` exports `must_be/2` and `library(clpz)` imports other predicates from `error` but defines its own `must_be/2`, both can coexist.
- Module-qualified calls use the syntax `Module:Goal` and resolve only against the specified module's predicates (and built-ins).
- Export lists control which predicates are accessible from outside the module; attempting to call a non-exported predicate via `Module:Pred` raises a permission error.
- The default module for non-module code is `user` and its predicates are globally accessible.
- **Predicate resolution order**: current module → imported predicates → user module → built-ins.

### Standard Library

The `./library/` directory contains standard Prolog library modules that define reusable predicates and operators. These are loaded via `:- use_module(library(Name))` directives.

#### Operator and Predicate Exports

Library modules export both predicates and operators through the module declaration:

```prolog
:- module(lists, [
    append/3,
    member/2,
    length/2,
    % ... exported predicates
]).

% Operators can also be exported if they are used by exported predicates:
:- op(700, xfx, '=>').
% If => is exported and used by an exported predicate, it becomes available
```

#### Operator Precedence Handling

1. **Parser State**: Operators declared in library modules are collected before parsing any dependent code. When a module is loaded via `use_module/1,2`, its operators are registered in the operator table.

2. **Inheritance**: Operators from imported modules become available to the importing code, allowing custom syntax defined in libraries to be used seamlessly.

3. **Resolution Order**: When resolving predicates in module-qualified calls (`module:goal`), the engine:
   - First checks the specified module's clauses
   - Falls back to built-ins (always visible)
   - Enforces export restrictions (non-exported predicates raise `permission_error`)

4. **Dynamic Updates**: The `:- op(Precedence, Type, Name)` directive can be used within library modules to define custom operators that become available to dependent code through proper module loading.

#### Library Module Structure

Standard library modules follow this pattern:

```prolog
:- module(module_name, [exported_pred/1, exported_pred/2]).

% Operator declarations (if needed)
:- op(500, yfx, my_op).

% Exported predicate implementations
exported_pred(X) :- % implementation

% Private helper predicates (not exported)
helper_pred(X) :- % implementation
```

Modules in `./library/` are loaded with precedence over user-defined modules, allowing the standard library to provide foundational functionality that can be extended or overridden.

## Limitations

This interpreter intentionally focuses on ISO core features. Significant gaps
you should be aware of:

- File/stream I/O predicates (`see/1`, `read/1`, `open/3`, etc.) and character
  I/O helpers are stubbed or missing.
- Directive handling (`dynamic/1`, `multifile/1`, `op/3`, etc.) now wires
  predicate properties and operator table updates, but the parser still applies
  only the built-in operator set when reading source code.
- ISO error term infrastructure (`error(ErrorType, Context)` along with
  `instantiation_error`, `type_error`, etc.) still needs work; most built-ins
  fail silently instead of raising structured errors.
- Character code hex escapes (`0'\\xHH`) are supported alongside other character code forms.
- `base'char'number` syntax (e.g., `16'mod'2`) is intentionally not implemented.
  This is distinct from Edinburgh `<radix>'<number>` syntax (e.g., `16'ff'`, `36'ZZZ`) which IS supported.
  This is an extremely obscure ISO edge case with ambiguous semantics in the
  standard, no real-world usage, and would require significant parser
  restructuring for minimal value.
- No DCG, module system, CLP libraries, or tail-call optimization. Recursion depth is limited to prevent Python stack overflow (default: 500 levels).

## Test Coverage Snapshot

As of 2025-11-23 the pytest suite reports `878 passed, 4 skipped` (out of 882
collected) via `uv run pytest`. The skips are parser stress cases that require
future ISO syntax additions; everything else (unification, type checks,
arithmetic, lists, control flow, meta-predicates) currently passes.
