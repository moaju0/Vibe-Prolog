{
  "repository": "nlothian/Vibe-Prolog",
  "issues": [
    {
      "number": 190,
      "title": "Implement retractall/1 predicate",
      "url": "https://github.com/nlothian/Vibe-Prolog/issues/190",
      "parent": null,
      "blocked_by": [],
      "blocking": [],
      "description": "## Summary\n\nThe `retractall/1` predicate is missing from Vibe-Prolog. This is a standard ISO Prolog predicate used to retract all clauses matching a given pattern from the dynamic database. It is needed for many Prolog programs, including the birds.pl expert system example.\n\n## Current Behavior\n\nWhen code calls `retractall(Pattern)`, the predicate is not found and the query fails, causing programs that depend on it to fail silently.\n\nExample failure:\n```prolog\n?- retractall(known/3).\nfalse.\n```\n\n## Expected Behavior\n\n`retractall/1` should:\n1. Remove all clauses from the database that match the given pattern\n2. Always succeed, even if no clauses match (unlike `retract/1` which fails if nothing matches)\n3. Only work on predicates declared as `dynamic`, raising a permission error for static predicates\n4. Be deterministic (succeed once, not backtrack)\n\nExample usage:\n```prolog\n:- dynamic fact/1.\n\n?- assertz(fact(a)), assertz(fact(b)), assertz(fact(c)).\ntrue.\n\n?- retractall(fact(_)).\ntrue.\n\n?- fact(X).\nfalse.\n```\n\n## Implementation Steps\n\n### 1. Locate the database built-ins module\nFind the file `vibeprolog/builtins/database.py` which contains other database manipulation predicates like `retract/1`, `asserta/1`, `assertz/1`, and `abolish/1`.\n\n### 2. Implement the `_builtin_retractall` method\nAdd a new static method to the `DatabaseBuiltins` class. This should:\n- Accept the standard builtin signature: `(args, subst, engine)`\n- Extract and dereference the clause pattern from `args[0]`\n- Find all clauses that unify with the pattern (similar to `retract/1`)\n- Check that all matched predicates have the `dynamic` property (use `_ensure_dynamic_permission`)\n- Remove all matching clauses from:\n  - The main `engine.clauses` list\n  - The first-argument index (`engine._first_arg_index`)\n  - The variable first-argument clauses index (`engine._variable_first_arg_clauses`)\n  - Module predicates if applicable\n- Update clause indices after removal\n- Return the original substitution once (deterministic - no backtracking)\n- Always succeed, even if no clauses matched\n\nKey differences from `retract/1`:\n- `retract/1` yields multiple substitutions (one per retracted clause) for backtracking\n- `retractall/1` retracts everything at once and succeeds exactly once\n- `retractall/1` succeeds even when no clauses match\n\n### 3. Register the predicate\nIn the `register` method of `DatabaseBuiltins`, add:\n```python\nregister_builtin(registry, \"retractall\", 1, DatabaseBuiltins._builtin_retractall)\n```\n\nPlace this registration near the `retract/1` registration for logical grouping.\n\n### 4. Write comprehensive tests\nCreate tests in `tests/test_builtins.py` or a new file `tests/test_retractall.py` covering:\n\n**Basic functionality:**\n- Retracting all clauses matching a pattern\n- Retracting with uninstantiated variables (e.g., `retractall(foo(_))`)\n- Retracting from an empty database (should succeed)\n- Retracting when no clauses match (should succeed)\n\n**Permission checks:**\n- Attempting to retract from a static predicate (should raise `permission_error`)\n- Successfully retracting from a dynamic predicate\n\n**Determinism:**\n- Verify it succeeds exactly once (doesn't backtrack)\n- Verify the substitution returned is the original (no new bindings)\n\n**Complex patterns:**\n- Retracting with partial instantiation (e.g., `retractall(foo(X, bar))`)\n- Retracting facts vs rules\n- Retracting from predicates with multiple arities\n\n**Module interaction:**\n- Retracting from module predicates\n- Verify clauses are removed from module predicate lists\n\n**Index maintenance:**\n- Verify first-argument index is updated correctly\n- Verify variable first-argument index is updated correctly\n- Test with predicates that have indexed first arguments\n- Test with predicates that have variable first arguments\n\n**Integration with other predicates:**\n- Use `retractall/1` then verify with `clause/2` that clauses are gone\n- Use `retractall/1` in combination with `asserta/1` and `assertz/1`\n- Verify behavior matches standard Prolog implementations (SWI-Prolog, GNU Prolog)\n\n### 5. Update FEATURES.md\nAdd `retractall/1` to the \"\u00a78.9 \u2014 Dynamic Program Modification\" section:\n\n```markdown\n| `retractall/1`                       | \u2705      | **ISO-required** - Retract all matching clauses |\n```\n\nPlace it right after the `retract/1` entry.\n\nAlso update the \"ISO Conformance Snapshot\" section if it mentions database operations as incomplete.\n\n### 6. Test with the birds.pl example\nAfter implementation, verify that `examples/birds.pl` works correctly:\n```bash\nuv run vibeprolog.py examples/birds.pl\n```\n\nThen query:\n```prolog\n?- birds:solve.\n```\n\nThe expert system should start asking questions about bird characteristics.\n\n## Reference Implementation\n\nLook at the existing `_builtin_retract` method in `vibeprolog/builtins/database.py` for patterns on:\n- How to iterate through clauses\n- How to unify with clause patterns\n- How to check dynamic permissions\n- How to update indices after removal\n\nThe main difference is that `retractall` should collect all matches, remove them all, and succeed once, rather than yielding for each match.\n\n## Acceptance Criteria\n\n- [ ] `retractall/1` predicate is implemented and registered\n- [ ] All tests pass including new `retractall/1` tests\n- [ ] Permission errors are raised for static predicates\n- [ ] The predicate succeeds even when no clauses match\n- [ ] Indices are correctly maintained after retraction\n- [ ] FEATURES.md is updated\n- [ ] The birds.pl example works correctly\n- [ ] Behavior matches ISO Prolog standard\n\n## Related Files\n\n- Implementation: `vibeprolog/builtins/database.py`\n- Tests: `tests/test_builtins.py` or `tests/test_retractall.py`\n- Documentation: `FEATURES.md`\n- Example: `examples/birds.pl`",
      "comments": [],
      "labels": [],
      "milestones": [],
      "linked_branches": []
    },
    {
      "number": 172,
      "title": "Implement Meta-Predicates & Term Utilities (forall, ignore, apply, term_variables, numbervars, subsumes_term)",
      "url": "https://github.com/nlothian/Vibe-Prolog/issues/172",
      "parent": null,
      "blocked_by": [],
      "blocking": [],
      "description": "## Problem\n\nVibe-Prolog is missing important meta-predicates and term manipulation utilities. These predicates are essential for control flow patterns and term introspection.\n\nExamples that currently fail:\n```prolog\n?- forall(member(X, [1,2,3]), X > 0).\nfalse.  % Should succeed (all elements > 0)\n\n?- term_variables(foo(X, Y, X), Vars).\nfalse.  % Should return Vars = [X, Y]\n\n?- ignore(fail).\nfalse.  % Should succeed (ignore failure)\n```\n\n## Required Predicates\n\n### Module: `vibeprolog/builtins/control.py` (Meta-Predicates)\n\n### 1. `forall/2` \u2b50 VERY COMMON\nUniversal quantification - succeeds if Condition implies Action for all solutions.\n\n**Signature:** `forall(+Condition, +Action)`\n\nEquivalent to: `\\+ (Condition, \\+ Action)`\n\n**Examples:**\n```prolog\n?- forall(member(X, [1,2,3]), X > 0).\ntrue.  % All elements satisfy condition\n\n?- forall(member(X, [1,2,3]), X < 3).\nfalse.  % Not all elements < 3\n\n?- forall(member(X, []), write(X)).\ntrue.  % Vacuously true (no solutions)\n\n?- forall(between(1, 5, X), (Y is X * 2, Y < 11)).\ntrue.\n\n?- forall(between(1, 5, X), (Y is X * 2, Y < 10)).\nfalse.  % Fails for X=5\n```\n\n**Error conditions:**\n- None (fails if Action fails for any Condition solution)\n\n### 2. `ignore/1`\nCall goal but always succeed (ignore failure).\n\n**Signature:** `ignore(+Goal)`\n\nEquivalent to: `(Goal -> true ; true)`\n\n**Examples:**\n```prolog\n?- ignore(true).\ntrue.\n\n?- ignore(fail).\ntrue.  % Succeeds despite goal failing\n\n?- ignore(write('hello')).\nhello\ntrue.  % Side effect occurs\n\n?- ignore(member(X, [])).\ntrue.  % No solutions but succeeds\n\n?- ignore(throw(error)).\n% Still throws - doesn't catch exceptions!\n```\n\n**Note:** `ignore/1` does NOT catch exceptions, only converts failure to success.\n\n### 3. `apply/2`\nCall goal with additional arguments from list.\n\n**Signature:** `apply(+Goal, +Arguments)`\n\n**Examples:**\n```prolog\n?- apply(append, [[1,2], [3,4], X]).\nX = [1,2,3,4].\n\n?- apply(plus(2), [3, X]).\nX = 5.  % Calls plus(2, 3, X)\n\n?- apply(write, [hello]).\nhello\ntrue.\n\n?- apply(member(X), [[a,b,c]]).\nX = a ;\nX = b ;\nX = c.\n```\n\n**Error conditions:**\n- `instantiation_error` if Goal is uninstantiated\n- `type_error(callable, Goal)` if Goal is not callable\n- `type_error(list, Arguments)` if Arguments is not a list\n\n---\n\n### Module: `vibeprolog/builtins/term_manipulation.py` (Term Utilities)\n\n### 4. `term_variables/2` \u2b50 ISO-REQUIRED\nExtract all variables from a term (in left-to-right order, no duplicates).\n\n**Signature:** `term_variables(@Term, -Variables)`\n\n**Examples:**\n```prolog\n?- term_variables(foo(X, Y, X), Vars).\nVars = [X, Y].  % X appears twice but listed once\n\n?- term_variables(foo(a, b, c), Vars).\nVars = [].  % No variables\n\n?- term_variables([X, Y, f(X, Z)], Vars).\nVars = [X, Y, Z].\n\n?- term_variables(X, Vars).\nVars = [X].\n\n?- term_variables(42, Vars).\nVars = [].\n```\n\n**Order:** Variables appear in the order first encountered during left-to-right depth-first traversal.\n\n**Error conditions:**\n- None (always succeeds)\n\n### 5. `numbervars/3`\nNumber variables for readable output (convert `Var` to `$VAR(N)`).\n\n**Signature:** `numbervars(+Term, +Start, -End)`\n\n**Examples:**\n```prolog\n?- numbervars(foo(X, Y, X), 0, End).\nX = '$VAR'(0), Y = '$VAR'(1), End = 2.\n\n?- numbervars(bar(A, B, C), 5, End).\nA = '$VAR'(5), B = '$VAR'(6), C = '$VAR'(7), End = 8.\n\n?- numbervars(test(a, b), 0, End).\nEnd = 0.  % No variables\n\n?- term_variables(foo(X, Y), Vars), numbervars(foo(X, Y), 0, _),\n   write_term(foo(X, Y), [numbervars(true)]).\nfoo(A, B)  % With numbervars option in write_term\ntrue.\n```\n\n**Behavior:**\n- Unifies each variable with `$VAR(N)` where N is a sequential number\n- Shared variables get the same number\n- Returns End = Start + (number of distinct variables)\n\n**Error conditions:**\n- `type_error(integer, Start)` if Start is not an integer\n\n### 6. `subsumes_term/2`\nOne-way unification test (checks if General is more general than Specific).\n\n**Signature:** `subsumes_term(@General, @Specific)`\n\n**Examples:**\n```prolog\n?- subsumes_term(f(X), f(a)).\ntrue.  % f(X) subsumes f(a)\n\n?- subsumes_term(f(a), f(X)).\nfalse.  % f(a) doesn't subsume f(X)\n\n?- subsumes_term(f(X, X), f(a, a)).\ntrue.\n\n?- subsumes_term(f(X, X), f(a, b)).\nfalse.  % X can't be both a and b\n\n?- subsumes_term(f(X, Y), f(a, b)).\ntrue.\n\n?- subsumes_term(f(a, Y), f(X, b)).\nfalse.  % a doesn't subsume X\n\n?- subsumes_term(_, anything).\ntrue.  % Variable subsumes everything\n```\n\n**Definition:** `subsumes_term(General, Specific)` succeeds if there exists a substitution \u03b8 such that General\u00b7\u03b8 = Specific, without binding variables in either term.\n\n**Error conditions:**\n- None (always succeeds or fails, never errors)\n\n## Implementation Steps\n\n### Part 1: Meta-Predicates\n\n1. **Open `vibeprolog/builtins/control.py`:**\n\n2. **Implement `forall/2`:**\n   - Expand to: `\\+ (Condition, \\+ Action)`\n   - Find all solutions to Condition\n   - For each solution, check if Action succeeds\n   - Succeed only if Action succeeds for ALL solutions\n   - Implement as: collect all Condition solutions, verify each satisfies Action\n\n3. **Implement `ignore/1`:**\n   - Try to execute Goal\n   - If it succeeds or fails, return success\n   - If it throws, re-throw (don't catch exceptions)\n   - Simple wrapper: `(Goal -> true ; true)`\n\n4. **Implement `apply/2`:**\n   - Check Goal is callable (atom or compound)\n   - Convert Goal to compound if it's an atom\n   - Append Arguments to Goal's existing args\n   - Call the extended goal\n   - Must support backtracking if goal is non-deterministic\n\n5. **Register meta-predicates:**\n   ```python\n   register_builtin(registry, \"forall\", 2, ControlBuiltins._builtin_forall)\n   register_builtin(registry, \"ignore\", 1, ControlBuiltins._builtin_ignore)\n   register_builtin(registry, \"apply\", 2, ControlBuiltins._builtin_apply)\n   ```\n\n### Part 2: Term Utilities\n\n6. **Open `vibeprolog/builtins/term_manipulation.py`:**\n\n7. **Implement `term_variables/2`:**\n   - Traverse term recursively (depth-first, left-to-right)\n   - Collect all unbound variables\n   - Use a set to track seen variables (no duplicates)\n   - Preserve order of first occurrence\n   - Return as list\n\n8. **Implement `numbervars/3`:**\n   - Traverse term collecting variables (use term_variables logic)\n   - For each distinct variable, unify with `$VAR(N)`\n   - Increment N for each variable\n   - Return final N as End\n   - Note: This MODIFIES the term (unifies variables)\n\n9. **Implement `subsumes_term/2`:**\n   - Create fresh copies of both terms\n   - Try to unify General_copy with Specific\n   - Check if original General and Specific are unchanged\n   - Alternative: Try to match General to Specific with one-way unification\n   - DO NOT bind variables in original terms\n\n10. **Register term utilities:**\n    ```python\n    register_builtin(registry, \"term_variables\", 2, TermManipulationBuiltins._builtin_term_variables)\n    register_builtin(registry, \"numbervars\", 3, TermManipulationBuiltins._builtin_numbervars)\n    register_builtin(registry, \"subsumes_term\", 2, TermManipulationBuiltins._builtin_subsumes_term)\n    ```\n\n### Part 3: Testing\n\n11. **Create `tests/test_meta_predicates.py`:**\n    - Test class `TestForall`:\n      - Test with various conditions and actions\n      - Test vacuous truth (no solutions to condition)\n      - Test failure cases\n    - Test class `TestIgnore`:\n      - Test with succeeding goals\n      - Test with failing goals\n      - Test side effects still occur\n      - Verify exceptions are NOT caught\n    - Test class `TestApply`:\n      - Test with atoms and compounds\n      - Test backtracking\n      - Test error cases\n\n12. **Extend `tests/test_term_manipulation.py`:**\n    - Test class `TestTermVariables`:\n      - Test variable extraction\n      - Test ordering\n      - Test duplicates removed\n      - Test nested structures\n    - Test class `TestNumbervars`:\n      - Test variable numbering\n      - Test shared variables get same number\n      - Test starting offset\n      - Test End value\n    - Test class `TestSubsumesTerm`:\n      - Test subsumption cases\n      - Test non-subsumption\n      - Test shared variables in General\n      - Verify original terms unchanged\n\n13. **Run tests:**\n    ```bash\n    uv run pytest tests/test_meta_predicates.py -v\n    uv run pytest tests/test_term_manipulation.py -v\n    uv run pytest  # All tests\n    ```\n\n### Part 4: Update Documentation\n\n14. **Update FEATURES.md:**\n    - Change `forall/2`, `ignore/1`, `apply/2` from \u274c to \u2705 (lines 202-204)\n    - Change `term_variables/2`, `numbervars/3`, `subsumes_term/2` from \u274c to \u2705 (lines 122-124)\n    - Update ISO Blocking Issues section\n\n## Implementation Hints\n\n**For `forall/2`:**\n```python\n# Collect all solutions to Condition\ncondition_solutions = list(engine.query(condition, subst))\n\nif not condition_solutions:\n    # Vacuously true\n    return subst\n\n# Check Action succeeds for each solution\nfor cond_subst in condition_solutions:\n    action_solutions = list(engine.query(action, cond_subst))\n    if not action_solutions:\n        return None  # Action failed for this condition\n        \nreturn subst  # All actions succeeded\n```\n\n**For `term_variables/2`:**\n```python\ndef collect_variables(term, subst, seen=None):\n    if seen is None:\n        seen = set()\n    vars_list = []\n    \n    term = deref(term, subst)\n    \n    if isinstance(term, Variable):\n        if id(term) not in seen:\n            seen.add(id(term))\n            vars_list.append(term)\n    elif isinstance(term, Compound):\n        for arg in term.args:\n            vars_list.extend(collect_variables(arg, subst, seen))\n    elif isinstance(term, List):\n        for elem in term.elements:\n            vars_list.extend(collect_variables(elem, subst, seen))\n        if term.tail:\n            vars_list.extend(collect_variables(term.tail, subst, seen))\n    \n    return vars_list\n```\n\n**For `subsumes_term/2`:**\n```python\n# Copy both terms with fresh variables\ngeneral_copy = copy_term_recursive(general, {}, engine._fresh_variable)\nspecific_deref = deref(specific, subst)\n\n# Try to unify the copy with specific\ntemp_subst = {}\nresult = unify(general_copy, specific_deref, temp_subst)\n\n# Succeed only if unification succeeded\nreturn subst if result is not None else None\n```\n\n## Success Criteria\n\n- [ ] All 6 predicates implemented and registered\n- [ ] `forall/2` implements universal quantification correctly\n- [ ] `ignore/1` converts failure to success (but re-throws exceptions)\n- [ ] `apply/2` calls goals with additional arguments\n- [ ] `term_variables/2` extracts variables in correct order\n- [ ] `numbervars/3` numbers variables sequentially\n- [ ] `subsumes_term/2` checks subsumption without binding\n- [ ] All predicates have proper error handling\n- [ ] Comprehensive tests added\n- [ ] All tests pass\n- [ ] FEATURES.md updated\n\n## Related\n\n- ISO \u00a78.5 - Term manipulation (term_variables, subsumes_term)\n- Common extensions (forall, ignore, apply, numbervars)\n- FEATURES.md lines 122-124, 202-204\n- Existing `vibeprolog/builtins/control.py`\n- Existing `vibeprolog/builtins/term_manipulation.py`",
      "comments": [],
      "labels": [],
      "milestones": [],
      "linked_branches": []
    },
    {
      "number": 160,
      "title": "op/3 Operator Parsing Upgrade",
      "url": "https://github.com/nlothian/Vibe-Prolog/issues/160",
      "parent": null,
      "blocked_by": [],
      "blocking": [],
      "description": "## Dynamic Operator Parsing (op/3)\n\nWe currently honor `:- op/3` in the `OperatorTable`, but `PrologParser` never consults it  \n(`vibeprolog/parser.py`, lines 533\u2013538). As a result, the parser still uses a static\ngrammar and custom operators have no effect on how clauses are parsed.\n\n### Problem\n\n- `op/3` directives correctly update the `OperatorTable`.\n- However, the grammar used by `PrologParser` is static.\n- Operator-heavy expressions are parsed without reference to the current operator\n  definitions, so user-defined operators do not work.\n\n### Proposed Approach\n\nReplace or augment the grammar\u2019s handling of operator expressions with a\nprecedence-aware parsing step:\n\n- Keep **Lark** for:\n  - Clause-level structure\n  - Tokens\n  - Comments\n  - Term boundaries\n- When an expression contains operator symbols:\n  - Hand its token stream to a **Pratt-style** parser.\n  - That parser must consult the current `OperatorTable` for precedence and associativity.\n  - The resulting AST/term must be built using the active operator definitions.\n\nBecause the `OperatorTable` is updated by `op/3`, this ensures that new operator\ndefinitions immediately affect all subsequently parsed clauses.\n\n### Implementation Steps\n\n1. **Locate operator-heavy parsing**\n   - Identify where Lark currently builds operator-rich terms\n     (likely in `PrologParser` or helper functions invoked by\n     `parse_term` / clause parsing).\n   - Isolate the token streams corresponding to those expressions.\n\n2. **Implement a precedence-aware parser**\n   - Use either:\n     - A Pratt parser,\n   - This parser must:\n     - Accept a token sequence and the current `OperatorTable`.\n     - Determine binding powers from operator precedence and associativity.\n     - Construct prefix, infix, and postfix terms accordingly.\n\n3. **Integrate with PrologParser**\n   - Update `PrologParser` so that ambiguous/operator-containing expressions are\n     routed through the custom precedence-aware parser instead of static grammar rules.\n\n4. **Handle dynamic updates**\n   - Ensure `:- op/3` directives continue to update `OperatorTable`\n     (already handled by the built-in).\n   - Ensure subsequent clauses are parsed using the updated operator definitions.\n\n5. **Add regression tests**\n   - Add tests (e.g. `tests/test_parser_compatibility.py`) that demonstrate:\n     - Operators declared via `op/3`\n     - Are usable in subsequent clauses\n     - In infix, prefix, and postfix positions.\n\n7. All tests must pass\n  - All existing test should continue to pass \n\n6. **Update FEATURES.md**\n  - Update FEATURES.md with this\n\n### Outcome\n\nThe parser will respect the dynamic operator table, restoring ISO compliance\n(ISO \u00a76.3). Expressions using user-defined operators will parse correctly and\nimmediately reflect changes introduced by `op/3` directives.\n\n",
      "comments": [],
      "labels": [],
      "milestones": [],
      "linked_branches": []
    },
    {
      "number": 155,
      "title": "Implement extended file I/O predicates",
      "url": "https://github.com/nlothian/Vibe-Prolog/issues/155",
      "parent": null,
      "blocked_by": [],
      "blocking": [],
      "description": "## Overview\n\nThis task implements additional ISO Prolog I/O predicates to improve compatibility with classic Prolog programs. While basic file I/O exists (`open/3`, `close/1`, `read/1`, etc.), many common predicates used in older Prolog code are missing.\n\n## Why This Matters\n\n- **Compatibility**: Many classic Prolog programs use `see/tell` style I/O\n- **Completeness**: Fills gaps in ISO I/O predicate coverage\n- **User Experience**: Common predicates users expect to be available\n- **Stream Management**: Better control over I/O streams\n\n## Background: Current State\n\n**Already Implemented** \u2705:\n- `open/3` \u2013 Open file stream\n- `close/1` \u2013 Close stream\n- `read/1`, `read/2` \u2013 Read term from stream\n- `get_char/1`, `get_char/2` \u2013 Read character\n- `put_char/1`, `put_char/2` \u2013 Write character\n- `current_input/1` \u2013 Get current input stream\n- `current_output/1` \u2013 Get current output stream\n- `write/1`, `writeln/1`, `nl/0` \u2013 Basic output\n\n**Missing** \u274c:\n- `see/1`, `seen/0` \u2013 Classic input file handling\n- `tell/1`, `told/0` \u2013 Classic output file handling\n- `get/1`, `get/2` \u2013 Read character code (old style)\n- `put/1`, `put/2` \u2013 Write character code (old style)\n- `at_end_of_stream/0`, `at_end_of_stream/1` \u2013 EOF detection\n- `stream_property/2` \u2013 Query stream properties\n- `set_input/1`, `set_output/1` \u2013 Redirect current streams\n- `flush_output/0`, `flush_output/1` \u2013 Explicit buffer flush\n\n## Prerequisites\n\n1. **Understand existing I/O implementation**:\n   - Review `vibeprolog/builtins/io.py`\n   - Understand how streams are managed\n   - See how `open/3` and `close/1` work\n\n2. **Understand ISO I/O model**:\n   - Read ISO/IEC 13211-1 Section 8.11 (Stream I/O)\n   - Understand stream handles vs. classic see/tell model\n   - Know the difference between old and new I/O styles\n\n3. **Review stream error handling**:\n   - Study how existing I/O predicates raise errors\n   - Understand `existence_error`, `permission_error`, etc.\n\n## Predicates to Implement\n\n### 1. see/1 (Classic Input Redirection)\n**Signature**: `see(+File)`\n\n**Description**: Open `File` for input and make it the current input stream. Old Edinburgh-style I/O.\n\n**Behavior**:\n- `see('input.txt')` \u2013 Opens input.txt for reading\n- Subsequent `read/1`, `get_char/1` read from this file\n- Previous input stream is saved (stack-based)\n\n**Error Cases**:\n- File doesn't exist \u2192 `existence_error(source_sink, File)`\n- File not readable \u2192 `permission_error(open, source_sink, File)`\n\n**Implementation Notes**:\n- Maintain stack of input streams\n- Push current input before switching\n- Use existing `open/3` internally\n\n### 2. seen/0 (Close Classic Input)\n**Signature**: `seen`\n\n**Description**: Close current input file opened by `see/1` and revert to previous input stream.\n\n**Behavior**:\n- `seen` \u2013 Closes file from `see/1`, returns to previous input\n- If no `see/1` was used, does nothing\n\n**Implementation Notes**:\n- Pop from input stream stack\n- Close the stream\n- Restore previous input\n\n### 3. tell/1 (Classic Output Redirection)\n**Signature**: `tell(+File)`\n\n**Description**: Open `File` for output and make it the current output stream.\n\n**Behavior**:\n- `tell('output.txt')` \u2013 Opens output.txt for writing\n- Subsequent `write/1`, `put_char/1` write to this file\n- Creates file if doesn't exist, truncates if exists\n\n**Error Cases**:\n- Directory doesn't exist \u2192 `existence_error(source_sink, File)`\n- File not writable \u2192 `permission_error(open, source_sink, File)`\n\n### 4. told/0 (Close Classic Output)\n**Signature**: `told`\n\n**Description**: Close current output file opened by `tell/1` and revert to previous output.\n\n**Behavior**:\n- `told` \u2013 Closes file from `tell/1`, returns to previous output\n\n### 5. get/1 (Read Character Code)\n**Signature**: `get(-Code)`\n\n**Description**: Read next character code from current input, skipping whitespace.\n\n**Behavior**:\n- `get(Code)` \u2013 Binds `Code` to ASCII value of next non-whitespace character\n- Skips spaces, tabs, newlines\n- Returns -1 on EOF\n\n**Error Cases**:\n- Input stream closed \u2192 `existence_error(stream, Stream)`\n\n### 6. get/2 (Read Character Code from Stream)\n**Signature**: `get(+Stream, -Code)`\n\n**Description**: Read next character code from specified stream.\n\n**Behavior**:\n- `get(Stream, Code)` \u2013 Like `get/1` but from `Stream`\n\n### 7. put/1 (Write Character Code)\n**Signature**: `put(+Code)`\n\n**Description**: Write character with given code to current output.\n\n**Behavior**:\n- `put(65)` \u2013 Writes 'A' (ASCII 65)\n- `put(10)` \u2013 Writes newline\n\n**Error Cases**:\n- Code not integer \u2192 `type_error(integer, Code)`\n- Code out of range \u2192 `representation_error(character_code)`\n\n### 8. put/2 (Write Character Code to Stream)\n**Signature**: `put(+Stream, +Code)`\n\n**Description**: Write character code to specified stream.\n\n### 9. at_end_of_stream/0\n**Signature**: `at_end_of_stream`\n\n**Description**: Succeeds if current input stream is at end-of-file.\n\n**Behavior**:\n- `at_end_of_stream` \u2013 True if EOF reached on current input\n\n### 10. at_end_of_stream/1\n**Signature**: `at_end_of_stream(+Stream)`\n\n**Description**: Succeeds if specified stream is at EOF.\n\n**Behavior**:\n- `at_end_of_stream(Stream)` \u2013 True if `Stream` at EOF\n\n**Error Cases**:\n- Stream not valid \u2192 `existence_error(stream, Stream)`\n\n### 11. stream_property/2\n**Signature**: `stream_property(?Stream, ?Property)`\n\n**Description**: Query or enumerate stream properties.\n\n**Properties**:\n- `file_name(File)` \u2013 Associated file name\n- `mode(Mode)` \u2013 `read`, `write`, or `append`\n- `input` \u2013 Stream is an input stream\n- `output` \u2013 Stream is an output stream\n- `alias(Alias)` \u2013 Stream alias name\n- `eof_action(Action)` \u2013 `error`, `eof_code`, or `reset`\n- `type(Type)` \u2013 `text` or `binary`\n\n**Behavior**:\n- `stream_property(S, file_name(F))` \u2013 Enumerate streams and their files\n- `stream_property(S, mode(read))` \u2013 Find all read streams\n\n### 12. set_input/1\n**Signature**: `set_input(+Stream)`\n\n**Description**: Set current input stream to `Stream`.\n\n**Behavior**:\n- `set_input(Stream)` \u2013 Make `Stream` current input\n- Different from `see/1` (doesn't maintain stack)\n\n**Error Cases**:\n- Stream not valid \u2192 `existence_error(stream, Stream)`\n- Stream not input \u2192 `permission_error(input, stream, Stream)`\n\n### 13. set_output/1\n**Signature**: `set_output(+Stream)`\n\n**Description**: Set current output stream to `Stream`.\n\n**Behavior**:\n- `set_output(Stream)` \u2013 Make `Stream` current output\n\n### 14. flush_output/0\n**Signature**: `flush_output`\n\n**Description**: Flush current output stream buffers.\n\n**Behavior**:\n- `flush_output` \u2013 Force write of buffered output to file/console\n\n### 15. flush_output/1\n**Signature**: `flush_output(+Stream)`\n\n**Description**: Flush specified output stream.\n\n**Behavior**:\n- `flush_output(Stream)` \u2013 Flush `Stream`'s buffers\n\n## Implementation Instructions\n\n### Step 1: Extend Stream Management\n\nAdd to `vibeprolog/builtins/io.py`:\n\n```python\nclass IOBuiltins:\n    # Class-level stream stacks for see/tell\n    _input_stack = []\n    _output_stack = []\n    _stream_properties = {}  # Stream handle -> properties dict\n    \n    @staticmethod\n    def _register_stream(handle, filename, mode, stream_type='text'):\n        \"\"\"Register a stream with its properties.\"\"\"\n        IOBuiltins._stream_properties[handle] = {\n            'file_name': filename,\n            'mode': mode,\n            'type': stream_type,\n            'input': mode in ['read', 'read_write'],\n            'output': mode in ['write', 'append', 'read_write'],\n        }\n    \n    @staticmethod\n    def _unregister_stream(handle):\n        \"\"\"Remove stream from property tracking.\"\"\"\n        if handle in IOBuiltins._stream_properties:\n            del IOBuiltins._stream_properties[handle]\n```\n\n### Step 2: Implement see/seen\n\n```python\n@staticmethod\ndef see(args, subst, engine):\n    \"\"\"see(+File) - Classic input redirection.\"\"\"\n    file_term = args[0]\n    filename = engine._deref(file_term, subst)\n    \n    # Type check\n    if not isinstance(filename, str):\n        raise PrologThrow(PrologError.type_error(\"atom\", filename, \"see/1\"))\n    \n    try:\n        # Open file\n        handle = open(filename, 'r')\n        \n        # Save current input\n        current = engine._current_input\n        IOBuiltins._input_stack.append(current)\n        \n        # Set new input\n        engine._current_input = handle\n        IOBuiltins._register_stream(handle, filename, 'read')\n        \n        yield subst\n        \n    except FileNotFoundError:\n        raise PrologThrow(PrologError.existence_error(\"source_sink\", filename, \"see/1\"))\n    except PermissionError:\n        raise PrologThrow(PrologError.permission_error(\"open\", \"source_sink\", filename, \"see/1\"))\n\n@staticmethod\ndef seen(args, subst, engine):\n    \"\"\"seen - Close classic input.\"\"\"\n    if IOBuiltins._input_stack:\n        # Close current input\n        if engine._current_input != sys.stdin:\n            engine._current_input.close()\n            IOBuiltins._unregister_stream(engine._current_input)\n        \n        # Restore previous\n        engine._current_input = IOBuiltins._input_stack.pop()\n    \n    yield subst\n```\n\n### Step 3: Implement tell/told\n\nSimilar to see/seen:\n\n```python\n@staticmethod\ndef tell(args, subst, engine):\n    \"\"\"tell(+File) - Classic output redirection.\"\"\"\n    file_term = args[0]\n    filename = engine._deref(file_term, subst)\n    \n    if not isinstance(filename, str):\n        raise PrologThrow(PrologError.type_error(\"atom\", filename, \"tell/1\"))\n    \n    try:\n        handle = open(filename, 'w')\n        \n        current = engine._current_output\n        IOBuiltins._output_stack.append(current)\n        \n        engine._current_output = handle\n        IOBuiltins._register_stream(handle, filename, 'write')\n        \n        yield subst\n        \n    except Exception as e:\n        raise PrologThrow(PrologError.permission_error(\"open\", \"source_sink\", filename, \"tell/1\"))\n\n@staticmethod\ndef told(args, subst, engine):\n    \"\"\"told - Close classic output.\"\"\"\n    if IOBuiltins._output_stack:\n        if engine._current_output != sys.stdout:\n            engine._current_output.close()\n            IOBuiltins._unregister_stream(engine._current_output)\n        \n        engine._current_output = IOBuiltins._output_stack.pop()\n    \n    yield subst\n```\n\n### Step 4: Implement get/put\n\n```python\n@staticmethod\ndef get(args, subst, engine):\n    \"\"\"get(-Code) - Read character code, skipping whitespace.\"\"\"\n    code_term = args[0]\n    \n    stream = engine._current_input\n    \n    # Skip whitespace\n    while True:\n        char = stream.read(1)\n        if not char:  # EOF\n            code = -1\n            break\n        if not char.isspace():\n            code = ord(char)\n            break\n    \n    # Unify\n    new_subst = unify(code_term, code, subst)\n    if new_subst is not None:\n        yield new_subst\n\n@staticmethod\ndef put(args, subst, engine):\n    \"\"\"put(+Code) - Write character code.\"\"\"\n    code_term = args[0]\n    code = engine._deref(code_term, subst)\n    \n    if not isinstance(code, int):\n        raise PrologThrow(PrologError.type_error(\"integer\", code, \"put/1\"))\n    \n    if code < 0 or code > 1114111:\n        raise PrologThrow(PrologError.representation_error(\"character_code\", \"put/1\"))\n    \n    stream = engine._current_output\n    stream.write(chr(code))\n    \n    yield subst\n```\n\n### Step 5: Implement at_end_of_stream\n\n```python\n@staticmethod\ndef at_end_of_stream(args, subst, engine):\n    \"\"\"at_end_of_stream - Check if current input at EOF.\"\"\"\n    stream = engine._current_input\n    \n    # Check EOF\n    pos = stream.tell()\n    char = stream.read(1)\n    if char:\n        stream.seek(pos)  # Reset position\n        return  # Not at EOF - fail\n    \n    yield subst  # At EOF - succeed\n```\n\n### Step 6: Implement stream_property\n\n```python\n@staticmethod\ndef stream_property(args, subst, engine):\n    \"\"\"stream_property(?Stream, ?Property) - Query stream properties.\"\"\"\n    stream_term, property_term = args\n    \n    stream = engine._deref(stream_term, subst)\n    prop = engine._deref(property_term, subst)\n    \n    # Enumerate all streams\n    for handle, props in IOBuiltins._stream_properties.items():\n        # Try to unify stream\n        s1 = unify(stream_term, handle, subst)\n        if s1 is None:\n            continue\n        \n        # Generate properties\n        for prop_name, prop_value in props.items():\n            if prop_name == 'file_name':\n                property = ('file_name', prop_value)\n            elif prop_name == 'mode':\n                property = ('mode', prop_value)\n            elif prop_name in ['input', 'output'] and prop_value:\n                property = prop_name\n            else:\n                continue\n            \n            # Try to unify property\n            s2 = unify(property_term, property, s1)\n            if s2 is not None:\n                yield s2\n```\n\n### Step 7: Implement set_input/set_output\n\n```python\n@staticmethod\ndef set_input(args, subst, engine):\n    \"\"\"set_input(+Stream) - Set current input stream.\"\"\"\n    stream_term = args[0]\n    stream = engine._deref(stream_term, subst)\n    \n    # Validate stream\n    if stream not in IOBuiltins._stream_properties:\n        raise PrologThrow(PrologError.existence_error(\"stream\", stream, \"set_input/1\"))\n    \n    if not IOBuiltins._stream_properties[stream]['input']:\n        raise PrologThrow(PrologError.permission_error(\"input\", \"stream\", stream, \"set_input/1\"))\n    \n    engine._current_input = stream\n    yield subst\n```\n\n### Step 8: Implement flush_output\n\n```python\n@staticmethod\ndef flush_output(args, subst, engine):\n    \"\"\"flush_output - Flush current output.\"\"\"\n    stream = engine._current_output\n    stream.flush()\n    yield subst\n```\n\n### Step 9: Register All Predicates\n\n```python\n@staticmethod\ndef register(registry, engine_ref=None):\n    \"\"\"Register all I/O built-ins.\"\"\"\n    # ... existing registrations ...\n    \n    # Classic I/O\n    registry[('see', 1)] = IOBuiltins.see\n    registry[('seen', 0)] = IOBuiltins.seen\n    registry[('tell', 1)] = IOBuiltins.tell\n    registry[('told', 0)] = IOBuiltins.told\n    \n    # Character code I/O\n    registry[('get', 1)] = IOBuiltins.get\n    registry[('get', 2)] = IOBuiltins.get_stream\n    registry[('put', 1)] = IOBuiltins.put\n    registry[('put', 2)] = IOBuiltins.put_stream\n    \n    # Stream management\n    registry[('at_end_of_stream', 0)] = IOBuiltins.at_end_of_stream\n    registry[('at_end_of_stream', 1)] = IOBuiltins.at_end_of_stream_stream\n    registry[('stream_property', 2)] = IOBuiltins.stream_property\n    registry[('set_input', 1)] = IOBuiltins.set_input\n    registry[('set_output', 1)] = IOBuiltins.set_output\n    registry[('flush_output', 0)] = IOBuiltins.flush_output\n    registry[('flush_output', 1)] = IOBuiltins.flush_output_stream\n```\n\n## Testing Requirements\n\n### Step 10: Create Test Suite\n\nCreate `tests/test_extended_io.py`:\n\n```python\n\"\"\"Tests for extended I/O predicates.\"\"\"\n\nimport pytest\nimport os\nimport tempfile\nfrom vibeprolog import PrologInterpreter\n\n\nclass TestClassicIO:\n    \"\"\"Test see/seen and tell/told.\"\"\"\n\n    def test_see_and_read(self):\n        \"\"\"see/1 opens file for input.\"\"\"\n        with tempfile.NamedTemporaryFile(mode='w', delete=False, suffix='.pl') as f:\n            f.write(\"fact(hello).\\n\")\n            f.write(\"fact(world).\\n\")\n            filename = f.name\n        \n        try:\n            prolog = PrologInterpreter()\n            prolog.query_once(f\"see('{filename}')\")\n            \n            # Read from file\n            result = prolog.query_once(\"read(X)\")\n            assert result is not None\n            # Should have read fact(hello)\n            \n            prolog.query_once(\"seen\")\n        finally:\n            os.unlink(filename)\n\n    def test_tell_and_write(self):\n        \"\"\"tell/1 opens file for output.\"\"\"\n        with tempfile.NamedTemporaryFile(mode='w', delete=False, suffix='.txt') as f:\n            filename = f.name\n        \n        try:\n            prolog = PrologInterpreter()\n            prolog.query_once(f\"tell('{filename}')\")\n            prolog.query_once(\"write(hello)\")\n            prolog.query_once(\"nl\")\n            prolog.query_once(\"told\")\n            \n            # Read back\n            with open(filename, 'r') as f:\n                content = f.read()\n            assert 'hello' in content\n        finally:\n            os.unlink(filename)\n\n    def test_see_nonexistent_file(self):\n        \"\"\"see/1 with nonexistent file raises error.\"\"\"\n        prolog = PrologInterpreter()\n        with pytest.raises(Exception) as exc_info:\n            prolog.query_once(\"see('/nonexistent/file.txt')\")\n        assert \"existence_error\" in str(exc_info.value)\n\n\nclass TestCharacterCodeIO:\n    \"\"\"Test get/put for character codes.\"\"\"\n\n    def test_put_writes_code(self):\n        \"\"\"put/1 writes character code.\"\"\"\n        prolog = PrologInterpreter()\n        # This is hard to test without capturing output\n        # Would need output capture\n        result = prolog.query_once(\"put(65)\")  # 'A'\n        assert result is not None\n\n    def test_get_reads_code(self):\n        \"\"\"get/1 reads character code.\"\"\"\n        # Would need input redirection to test properly\n        pass\n\n\nclass TestStreamProperties:\n    \"\"\"Test stream_property/2.\"\"\"\n\n    def test_query_stream_properties(self):\n        \"\"\"stream_property/2 enumerates streams.\"\"\"\n        with tempfile.NamedTemporaryFile(mode='w', delete=False) as f:\n            filename = f.name\n        \n        try:\n            prolog = PrologInterpreter()\n            prolog.query_once(f\"open('{filename}', write, S)\")\n            \n            # Query properties\n            results = list(prolog.query(\"stream_property(S, P)\"))\n            assert len(results) > 0\n            \n            prolog.query_once(\"close(S)\")\n        finally:\n            os.unlink(filename)\n\n\nclass TestEOFDetection:\n    \"\"\"Test at_end_of_stream.\"\"\"\n\n    def test_at_end_of_stream_empty_file(self):\n        \"\"\"at_end_of_stream/0 succeeds on empty file.\"\"\"\n        with tempfile.NamedTemporaryFile(mode='w', delete=False) as f:\n            filename = f.name\n        \n        try:\n            prolog = PrologInterpreter()\n            prolog.query_once(f\"see('{filename}')\")\n            \n            assert prolog.has_solution(\"at_end_of_stream\")\n            \n            prolog.query_once(\"seen\")\n        finally:\n            os.unlink(filename)\n\n\nclass TestFlushOutput:\n    \"\"\"Test flush_output.\"\"\"\n\n    def test_flush_output_succeeds(self):\n        \"\"\"flush_output/0 succeeds.\"\"\"\n        prolog = PrologInterpreter()\n        assert prolog.has_solution(\"flush_output\")\n```\n\n### Step 11: Run Tests\n\n```bash\n# Run I/O tests\nuv run pytest tests/test_extended_io.py -v\n\n# Run all tests\nuv run pytest\n```\n\n## Update Documentation\n\n### Step 12: Update FEATURES.md\n\nUpdate the Input/Output section:\n\n```markdown\n### Input/Output (ISO 8.11-8.12)\n- \u2705 `write/1` \u2013 Write term\n- \u2705 `writeln/1` \u2013 Write term with newline\n- \u2705 `nl/0` \u2013 Write newline\n- \u2705 `format/2`, `format/3` \u2013 Formatted output\n- \u2705 `read_from_chars/2` \u2013 Parse term from character list/string\n- \u2705 `write_term_to_chars/3` \u2013 Write term to character list with options\n- \u2705 `read/1`, `read/2` \u2013 Read term from input streams\n- \u2705 `get_char/1`, `get_char/2` \u2013 Read character from input\n- \u2705 `put_char/1`, `put_char/2` \u2013 Write character to output\n- \u2705 `open/3` \u2013 Open file stream\n- \u2705 `close/1` \u2013 Close stream\n- \u2705 `current_input/1` \u2013 Get current input stream\n- \u2705 `current_output/1` \u2013 Get current output stream\n- \u2705 `see/1` \u2013 Classic input file redirection\n- \u2705 `seen/0` \u2013 Close classic input\n- \u2705 `tell/1` \u2013 Classic output file redirection\n- \u2705 `told/0` \u2013 Close classic output\n- \u2705 `get/1`, `get/2` \u2013 Read character code (old style)\n- \u2705 `put/1`, `put/2` \u2013 Write character code (old style)\n- \u2705 `at_end_of_stream/0`, `at_end_of_stream/1` \u2013 EOF detection\n- \u2705 `stream_property/2` \u2013 Query stream properties\n- \u2705 `set_input/1` \u2013 Redirect current input stream\n- \u2705 `set_output/1` \u2013 Redirect current output stream\n- \u2705 `flush_output/0`, `flush_output/1` \u2013 Explicit buffer flush\n```\n\n## Validation Checklist\n\nBefore submitting your PR:\n\n- [ ] All 15 predicates implemented\n- [ ] Stream property tracking works\n- [ ] see/seen maintain input stack correctly\n- [ ] tell/told maintain output stack correctly\n- [ ] EOF detection works\n- [ ] Error handling for all edge cases\n- [ ] Test suite covers all predicates\n- [ ] Classic I/O compatible with modern stream I/O\n- [ ] FEATURES.md updated\n- [ ] All existing tests still pass\n- [ ] Code follows PEP8 style guidelines\n\n## Common Pitfalls\n\n1. **Stream lifecycle**: Ensure streams are properly closed\n2. **Stack management**: see/tell must maintain stacks correctly\n3. **EOF handling**: Different systems handle EOF differently\n4. **Buffering**: flush_output needs to actually flush\n5. **Error consistency**: Use same error patterns as existing I/O\n\n## Reference Materials\n\n- **ISO Standard**: ISO/IEC 13211-1 Section 8.11-8.12 (I/O)\n- **SWI-Prolog I/O**: https://www.swi-prolog.org/pldoc/man?section=io\n- **Classic Prolog I/O**: Edinburgh Prolog I/O model (see/tell)\n\n## Success Criteria\n\n- All predicates implemented and tested\n- Classic I/O (see/tell) works correctly\n- Stream management robust\n- FEATURES.md updated\n- All tests pass\n- Code follows project style guidelines\n",
      "comments": [],
      "labels": [],
      "milestones": [],
      "linked_branches": []
    },
    {
      "number": 154,
      "title": "Enable dynamic operator parsing",
      "url": "https://github.com/nlothian/Vibe-Prolog/issues/154",
      "parent": null,
      "blocked_by": [],
      "blocking": [],
      "description": "## Overview\n\nThis task enables the parser to recognize operators defined at runtime via `op/3` directives. Currently, `op/3` updates the operator table and `current_op/3` can query it, but the Lark parser only recognizes the built-in operator set. This means custom operators must be written in canonical functor notation.\n\n## Why This Matters\n\n- **Meta-programming**: Enables Prolog programs that define their own syntax\n- **DSLs**: Allows domain-specific languages written in Prolog\n- **Compatibility**: Many Prolog programs define custom operators\n- **ISO Compliance**: `op/3` should affect both runtime AND parsing\n\n## Background: Current State\n\n**What Works**:\n- `op/3` updates the operator table \u2705\n- `current_op/3` queries defined operators \u2705  \n- Operators are stored with precedence and associativity \u2705\n\n**What Doesn't Work**:\n- Parser doesn't use the updated operator table \u274c\n- Custom operators must use canonical syntax \u274c\n\n**Example**:\n```prolog\n% Define custom operator\n:- op(500, yfx, @).\n\n% What we want to write:\n?- a @ b @ c.\n\n% What currently works:\n?- @(@(a, b), c).\n\n% The parser only recognizes built-in operators!\n```\n\n## Prerequisites\n\n1. **Understand the parser**:\n   - Read `vibeprolog/parser.py` to understand Lark grammar\n   - Study how operators are currently defined in the grammar\n   - Understand precedence and associativity\n\n2. **Understand op/3**:\n   - Review `vibeprolog/builtins/reflection.py` for `op/3` and `current_op/3`\n   - Understand operator table structure\n   - Know the ISO operator types: `fx`, `fy`, `xfx`, `xfy`, `yfx`, `yfy`, `xf`, `yf`\n\n3. **Understand Lark**:\n   - Review Lark documentation: https://lark-parser.readthedocs.io/\n   - Understand how to dynamically create grammars\n   - Know how precedence works in Lark\n\n## Operator Types (ISO)\n\n### Prefix Operators\n- **fx**: Non-associative prefix (`- X`, but not `- - X`)\n- **fy**: Right-associative prefix (`- - X` allowed)\n\n### Infix Operators\n- **xfx**: Non-associative infix (`X = Y`, but not `X = Y = Z`)\n- **xfy**: Right-associative infix (`X -> Y -> Z` = `X -> (Y -> Z)`)\n- **yfx**: Left-associative infix (`X + Y + Z` = `(X + Y) + Z`)\n- **yfy**: Fully associative infix (rare)\n\n### Postfix Operators\n- **xf**: Non-associative postfix\n- **yf**: Left-associative postfix\n\n### Precedence\n- Lower number = higher precedence\n- 1-1200 in ISO Prolog\n- Operators with same precedence use associativity\n\n## Implementation Approaches\n\n### Option A: Dual-Pass Parsing (Recommended)\n\n**Strategy**: Parse twice - first to extract op directives, then with updated grammar.\n\n**Advantages**:\n- Works with existing Lark parser\n- Minimal changes to architecture\n- Operators available for subsequent clauses\n\n**Disadvantages**:\n- Two parsing passes\n- Slightly slower consultation\n\n**Implementation Steps**:\n1. First pass: Scan for `:-op(...)` directives using simple regex/parser\n2. Update operator table\n3. Generate new Lark grammar with custom operators\n4. Second pass: Parse full program with updated grammar\n\n### Option B: Post-Parse AST Transformation\n\n**Strategy**: Parse everything as canonical functors, then transform based on operator table.\n\n**Advantages**:\n- Single parse pass\n- Parser stays simple\n\n**Disadvantages**:\n- Complex AST transformation\n- Harder to get precedence right\n- Doesn't help with reading operator syntax\n\n### Option C: Pluggable Parser\n\n**Strategy**: Replace Lark with custom recursive-descent parser.\n\n**Advantages**:\n- Full control over parsing\n- Can handle dynamic operators natively\n\n**Disadvantages**:\n- Much more work\n- Have to reimplement all parsing logic\n- Higher maintenance burden\n\n**Recommendation**: Start with **Option A** (dual-pass) as it's the most pragmatic.\n\n## Implementation Instructions (Option A: Dual-Pass)\n\n### Step 1: Extract Operators from Source\n\nAdd to `vibeprolog/parser.py`:\n\n```python\nimport re\n\ndef extract_operators(source):\n    \"\"\"Extract op/3 directives from source code.\n    \n    Args:\n        source: Prolog source code string\n        \n    Returns:\n        List of (precedence, type, operator) tuples\n    \"\"\"\n    operators = []\n    \n    # Match :- op(Precedence, Type, Operator).\n    # This is a simple regex - won't handle all cases but covers common ones\n    pattern = r':-\\s*op\\s*\\(\\s*(\\d+)\\s*,\\s*(\\w+)\\s*,\\s*([\\w@#$&*+/<=>?^~-]+)\\s*\\)'\n    \n    for match in re.finditer(pattern, source):\n        precedence = int(match.group(1))\n        op_type = match.group(2)\n        operator = match.group(3)\n        operators.append((precedence, op_type, operator))\n    \n    return operators\n```\n\n### Step 2: Generate Dynamic Grammar\n\nAdd grammar generation method:\n\n```python\ndef generate_grammar_with_operators(base_grammar, operators):\n    \"\"\"Generate Lark grammar with custom operators.\n    \n    Args:\n        base_grammar: Base grammar string\n        operators: List of (precedence, type, operator) tuples\n        \n    Returns:\n        Updated grammar string\n    \"\"\"\n    # Start with base grammar\n    grammar = base_grammar\n    \n    # Group operators by precedence\n    ops_by_precedence = {}\n    for prec, op_type, op in operators:\n        if prec not in ops_by_precedence:\n            ops_by_precedence[prec] = []\n        ops_by_precedence[prec].append((op_type, op))\n    \n    # Generate operator rules\n    # This is simplified - full implementation needs to handle precedence correctly\n    operator_rules = []\n    \n    for prec in sorted(ops_by_precedence.keys()):\n        for op_type, op in ops_by_precedence[prec]:\n            # Escape special characters for Lark\n            escaped_op = op.replace('\\\\', '\\\\\\\\').replace('\"', '\\\\\"')\n            \n            if op_type in ['xfx', 'xfy', 'yfx', 'yfy']:  # Infix\n                operator_rules.append(f'    | term \"{escaped_op}\" term')\n            elif op_type in ['fx', 'fy']:  # Prefix\n                operator_rules.append(f'    | \"{escaped_op}\" term')\n            elif op_type in ['xf', 'yf']:  # Postfix\n                operator_rules.append(f'    | term \"{escaped_op}\"')\n    \n    # Insert into grammar (this is very simplified!)\n    # Real implementation needs proper precedence handling\n    if operator_rules:\n        grammar += \"\\n\" + \"\\n\".join(operator_rules)\n    \n    return grammar\n```\n\n**Note**: This is a simplified version. Full implementation requires:\n- Proper precedence integration into Lark's operator precedence system\n- Handling of x vs y associativity\n- Conflict detection between operators\n\n### Step 3: Update PrologParser for Two-Pass Parsing\n\nModify `vibeprolog/parser.py`:\n\n```python\nclass PrologParser:\n    def __init__(self, custom_operators=None):\n        \"\"\"Initialize parser with optional custom operators.\n        \n        Args:\n            custom_operators: List of (precedence, type, operator) tuples\n        \"\"\"\n        self.custom_operators = custom_operators or []\n        self.base_grammar = self._load_base_grammar()\n        self.parser = self._create_parser()\n    \n    def _load_base_grammar(self):\n        \"\"\"Load the base Prolog grammar.\"\"\"\n        # Load from prolog.lark file or inline definition\n        return PROLOG_GRAMMAR  # existing grammar\n    \n    def _create_parser(self):\n        \"\"\"Create Lark parser with custom operators.\"\"\"\n        if self.custom_operators:\n            grammar = generate_grammar_with_operators(\n                self.base_grammar,\n                self.custom_operators\n            )\n        else:\n            grammar = self.base_grammar\n        \n        return Lark(grammar, start='program', parser='lalr')\n    \n    def parse(self, source):\n        \"\"\"Parse Prolog source with two-pass approach.\"\"\"\n        # First pass: Extract operators\n        operators = extract_operators(source)\n        \n        if operators and operators != self.custom_operators:\n            # Operators found - rebuild parser\n            self.custom_operators = operators\n            self.parser = self._create_parser()\n        \n        # Second pass: Parse with updated grammar\n        try:\n            tree = self.parser.parse(source)\n            return self.transform(tree)\n        except Exception as e:\n            raise ValueError(f\"Parse error: {e}\")\n```\n\n### Step 4: Handle Operator Precedence Properly\n\nThis is the complex part. Lark has its own precedence mechanism. You need to:\n\n1. **Map ISO precedences to Lark**:\n   - ISO: 1 (highest) to 1200 (lowest)\n   - Lark: reverse (need to invert)\n\n2. **Handle associativity**:\n   - `yfx` (left) \u2192 Lark `?left`\n   - `xfy` (right) \u2192 Lark `?right`\n   - `xfx` (non) \u2192 no decorator\n\n3. **Generate precedence levels**:\n\n```python\ndef generate_precedence_grammar(operators):\n    \"\"\"Generate Lark grammar with proper precedence.\n    \n    ISO precedence: 1 (high) to 1200 (low)\n    Lark precedence: implicitly by rule order (first = low precedence)\n    \"\"\"\n    # Group by precedence (inverted - highest ISO = lowest Lark)\n    prec_levels = {}\n    for prec, op_type, op in sorted(operators, key=lambda x: -x[0]):\n        if prec not in prec_levels:\n            prec_levels[prec] = []\n        prec_levels[prec].append((op_type, op))\n    \n    # Generate rules in precedence order\n    rules = []\n    prev_rule = \"atom\"\n    \n    for prec in sorted(prec_levels.keys(), reverse=True):\n        rule_name = f\"expr_{prec}\"\n        alternatives = [f\"    | {prev_rule}\"]\n        \n        for op_type, op in prec_levels[prec]:\n            esc_op = escape_for_lark(op)\n            \n            if op_type == 'yfx':  # Left associative\n                alternatives.append(f\"    | {rule_name} \\\"{esc_op}\\\" {prev_rule}\")\n            elif op_type == 'xfy':  # Right associative  \n                alternatives.append(f\"    | {prev_rule} \\\"{esc_op}\\\" {rule_name}\")\n            elif op_type == 'xfx':  # Non-associative\n                alternatives.append(f\"    | {prev_rule} \\\"{esc_op}\\\" {prev_rule}\")\n            # ... handle other types\n        \n        rules.append(f\"{rule_name}:\\n\" + \"\\n\".join(alternatives))\n        prev_rule = rule_name\n    \n    return \"\\n\\n\".join(rules)\n```\n\n### Step 5: Update Interpreter to Use Parser with Operators\n\nModify `vibeprolog/interpreter.py`:\n\n```python\ndef consult_string(self, program):\n    \"\"\"Consult a Prolog program from string with operator support.\"\"\"\n    # Extract operators first\n    operators = extract_operators(program)\n    \n    # Create parser with these operators\n    parser = PrologParser(custom_operators=operators)\n    \n    # Parse program\n    parsed = parser.parse(program)\n    \n    # Process clauses and directives\n    for item in parsed:\n        if isinstance(item, Directive):\n            self._handle_directive(item)\n        else:\n            self._add_clause(item)\n```\n\n## Testing Requirements\n\n### Step 6: Create Test Suite\n\nCreate `tests/test_dynamic_operators.py`:\n\n```python\n\"\"\"Tests for dynamic operator parsing.\"\"\"\n\nimport pytest\nfrom vibeprolog import PrologInterpreter\n\n\nclass TestCustomOperators:\n    \"\"\"Test custom operator definitions.\"\"\"\n\n    def test_define_infix_operator(self):\n        \"\"\"Define and use custom infix operator.\"\"\"\n        prolog = PrologInterpreter()\n        prolog.consult_string(\"\"\"\n            :- op(500, xfx, @).\n            \n            a @ b.\n        \"\"\")\n        \n        # Should parse a @ b as @(a, b)\n        assert prolog.has_solution(\"@(a, b)\")\n\n    def test_operator_precedence(self):\n        \"\"\"Operators respect precedence.\"\"\"\n        prolog = PrologInterpreter()\n        prolog.consult_string(\"\"\"\n            :- op(400, xfy, +++).\n            :- op(500, xfy, ***).\n            \n            % a +++ b *** c should parse as a +++ (b *** c)\n            % because 400 < 500 (higher precedence)\n        \"\"\")\n        \n        result = prolog.query_once(\"X = (a +++ b *** c)\")\n        # Check structure\n        # Expected: +++(a, ***(b, c))\n\n    def test_left_associative_operator(self):\n        \"\"\"Left-associative operators group left.\"\"\"\n        prolog = PrologInterpreter()\n        prolog.consult_string(\"\"\"\n            :- op(500, yfx, !!).\n            \n            test(X) :- X = (a !! b !! c).\n        \"\"\")\n        \n        result = prolog.query_once(\"test(X)\")\n        # Should be: !!(\u200b!!(a, b), c)\n\n    def test_right_associative_operator(self):\n        \"\"\"Right-associative operators group right.\"\"\"\n        prolog = PrologInterpreter()\n        prolog.consult_string(\"\"\"\n            :- op(500, xfy, @@).\n            \n            test(X) :- X = (a @@ b @@ c).\n        \"\"\")\n        \n        result = prolog.query_once(\"test(X)\")\n        # Should be: @@(a, @@(b, c))\n\n    def test_prefix_operator(self):\n        \"\"\"Prefix operators work.\"\"\"\n        prolog = PrologInterpreter()\n        prolog.consult_string(\"\"\"\n            :- op(300, fy, ~~).\n            \n            fact(~~ x).\n        \"\"\")\n        \n        assert prolog.has_solution(\"fact(~~(x))\")\n\n    def test_postfix_operator(self):\n        \"\"\"Postfix operators work.\"\"\"\n        prolog = PrologInterpreter()\n        prolog.consult_string(\"\"\"\n            :- op(300, xf, !!).\n            \n            fact(x !!).\n        \"\"\")\n        \n        assert prolog.has_solution(\"fact(!!(x))\")\n\n    def test_operator_in_clause_head(self):\n        \"\"\"Operators work in clause heads.\"\"\"\n        prolog = PrologInterpreter()\n        prolog.consult_string(\"\"\"\n            :- op(500, xfx, likes).\n            \n            alice likes chocolate.\n            bob likes pizza.\n        \"\"\")\n        \n        assert prolog.has_solution(\"likes(alice, chocolate)\")\n        assert prolog.has_solution(\"alice likes chocolate\")\n\n    def test_operator_in_clause_body(self):\n        \"\"\"Operators work in clause bodies.\"\"\"\n        prolog = PrologInterpreter()\n        prolog.consult_string(\"\"\"\n            :- op(500, xfx, loves).\n            \n            compatible(X, Y) :- X loves Y, Y loves X.\n            \n            alice loves bob.\n            bob loves alice.\n        \"\"\")\n        \n        assert prolog.has_solution(\"compatible(alice, bob)\")\n\n    def test_multiple_operators(self):\n        \"\"\"Multiple operators can be defined.\"\"\"\n        prolog = PrologInterpreter()\n        prolog.consult_string(\"\"\"\n            :- op(400, xfx, +++).\n            :- op(500, xfx, ***).\n            :- op(600, xfx, ###).\n            \n            fact(a +++ b).\n            fact(c *** d).\n            fact(e ### f).\n        \"\"\")\n        \n        assert prolog.has_solution(\"fact(+++(a, b))\")\n        assert prolog.has_solution(\"fact(***(c, d))\")\n        assert prolog.has_solution(\"fact(###(e, f))\")\n\n    def test_current_op_returns_custom(self):\n        \"\"\"current_op/3 returns custom operators.\"\"\"\n        prolog = PrologInterpreter()\n        prolog.consult_string(\"\"\"\n            :- op(500, xfx, @@@).\n        \"\"\")\n        \n        result = prolog.query_once(\"current_op(500, xfx, @@@)\")\n        assert result is not None\n\n\nclass TestOperatorEdgeCases:\n    \"\"\"Test edge cases and error conditions.\"\"\"\n\n    def test_operator_conflicts(self):\n        \"\"\"Redefining operator should work.\"\"\"\n        prolog = PrologInterpreter()\n        prolog.consult_string(\"\"\"\n            :- op(500, xfx, @).\n            :- op(400, yfx, @).  % Redefine with different precedence\n        \"\"\")\n        \n        # Should use new definition\n        result = prolog.query_once(\"current_op(P, T, @)\")\n        assert result['P'] == 400\n        assert result['T'] == 'yfx'\n\n    def test_remove_operator(self):\n        \"\"\"op(0, _, Op) removes operator.\"\"\"\n        prolog = PrologInterpreter()\n        prolog.consult_string(\"\"\"\n            :- op(500, xfx, @).\n            :- op(0, xfx, @).  % Remove\n        \"\"\")\n        \n        # Should no longer be defined\n        result = prolog.query_once(\"current_op(_, _, @)\")\n        # Depending on implementation, might return None or fail\n\n    def test_builtin_operators_still_work(self):\n        \"\"\"Built-in operators still work.\"\"\"\n        prolog = PrologInterpreter()\n        prolog.consult_string(\"\"\"\n            :- op(500, xfx, @).\n            \n            test :- X is 2 + 3, X =:= 5.\n        \"\"\")\n        \n        assert prolog.has_solution(\"test\")\n```\n\n### Step 7: Run Tests\n\n```bash\n# Run operator tests\nuv run pytest tests/test_dynamic_operators.py -v\n\n# Run full suite\nuv run pytest\n```\n\n## Update Documentation\n\n### Step 8: Update FEATURES.md\n\nUpdate the Directives section:\n\n```markdown\n### Operator Directives\n- \u2705 `:- op/3` \u2013 Define operator (updates registry AND parser)\n- \u2705 Dynamic operator parsing (custom operators recognized in syntax)\n- \u2705 All ISO operator types supported (fx, fy, xfx, xfy, yfx, yfy, xf, yf)\n- \u2705 Proper precedence handling (1-1200)\n- \u2705 Operator removal via `op(0, _, Op)`\n```\n\nUpdate the Syntactic Constructs section:\n\n```markdown\n### Operators\n- \u2705 Arithmetic operators (`+`, `-`, `*`, `/`, `//`, `mod`, `**`)\n- \u2705 Comparison operators (`=`, `\\=`, `=:=`, `=\\=`, `<`, `=<`, `>`, `>=`)\n- \u2705 Control operators (`,`, `;`, `->`, `\\+`, `!`)\n- \u2705 Term comparison operators (`==`, `\\==`, `@<`, `@=<`, `@>`, `@>=`)\n- \u2705 Custom operators via `op/3` (fully parsed)\n```\n\n### Step 9: Update ARCHITECTURE.md\n\nAdd section on operator parsing:\n\n```markdown\n## Dynamic Operator Parsing\n\nThe parser supports dynamic operators defined via `op/3` directives.\n\n### Two-Pass Approach\n\n1. **First pass**: Scan source for `:- op(...)` directives\n2. **Update operator table**: Register operators with precedence and type\n3. **Regenerate grammar**: Create Lark grammar with custom operators\n4. **Second pass**: Parse full program with updated grammar\n\n### Operator Precedence\n\n- ISO precedence: 1 (highest) to 1200 (lowest)\n- Mapped to Lark's implicit precedence (rule order)\n- Operators at same precedence use associativity\n\n### Associativity Types\n\n- `yfx`: Left-associative (`a + b + c` = `(a + b) + c`)\n- `xfy`: Right-associative (`a -> b -> c` = `a -> (b -> c)`)\n- `xfx`: Non-associative (`a = b` only, not `a = b = c`)\n\n### Limitations\n\n- Operators must be defined before use in same file\n- Operator changes require re-parsing\n- Very complex operator combinations may have edge cases\n```\n\n## Validation Checklist\n\nBefore submitting your PR:\n\n- [ ] `extract_operators` function extracts op/3 directives\n- [ ] `generate_grammar_with_operators` creates valid Lark grammar\n- [ ] Parser can be recreated with custom operators\n- [ ] All ISO operator types supported (fx, fy, xfx, xfy, yfx, yfy, xf, yf)\n- [ ] Precedence handled correctly (1-1200)\n- [ ] Associativity handled correctly\n- [ ] Operators work in clause heads and bodies\n- [ ] `current_op/3` returns custom operators\n- [ ] Built-in operators still work\n- [ ] Test suite comprehensive\n- [ ] FEATURES.md updated\n- [ ] ARCHITECTURE.md updated\n- [ ] All existing tests still pass\n\n## Common Pitfalls\n\n1. **Precedence inversion**: ISO uses low numbers for high precedence; Lark is opposite\n2. **Associativity mapping**: Getting x/y mapping to Lark directives wrong\n3. **Escaping**: Special characters in operators need proper escaping for Lark\n4. **Order dependence**: Operators must be defined before use\n5. **Grammar conflicts**: Some operator combinations may conflict in Lark\n\n## Reference Materials\n\n- **ISO Standard**: ISO/IEC 13211-1 Section 6.3.4 (Operators)\n- **SWI-Prolog**: https://www.swi-prolog.org/pldoc/man?section=operators\n- **Lark Documentation**: https://lark-parser.readthedocs.io/en/latest/grammar.html\n- **Lark Precedence**: https://lark-parser.readthedocs.io/en/latest/tree_construction.html\n\n## Success Criteria\n\n- Custom operators can be defined and used\n- Precedence and associativity work correctly\n- All operator types supported\n- Operators work in all contexts (heads, bodies, queries)\n- FEATURES.md marks op/3 as fully implemented\n- Documentation complete\n- All tests pass\n- Code follows project style guidelines\n\n## Notes\n\nThis is a complex task. Consider:\n- Starting with simple infix operators first\n- Adding comprehensive tests at each step\n- Testing edge cases thoroughly\n- May need multiple iterations to handle all cases\n- Lark grammar generation can be tricky - test incrementally\n",
      "comments": [],
      "labels": [],
      "milestones": [],
      "linked_branches": []
    },
    {
      "number": 141,
      "title": "Implement Tail-Call Optimization or Deep Recursion Mitigation",
      "url": "https://github.com/nlothian/Vibe-Prolog/issues/141",
      "parent": null,
      "blocked_by": [],
      "blocking": [],
      "description": "## Summary\nPrevent Python stack overflow errors on deep recursion by implementing tail-call optimization (TCO) or an alternative mitigation strategy. This will improve scalability and allow typical recursive Prolog programs to run without hitting stack limits.\n\n## Dependencies\n- No blocking dependencies\n- Independent of DCG and module system issues\n\n## Implementation Instructions\n\n### 1. Research and Choose Approach\n\nEvaluate these options:\n\n**Option A: Tail-Call Optimization (TCO)**\n- Detect when a goal is in tail position\n- Instead of recursive call, update bindings and loop\n- Most efficient but complex to implement correctly\n\n**Option B: Trampolining**\n- Return continuations instead of making recursive calls\n- Execute continuations iteratively in a loop\n- Easier to implement, moderate overhead\n\n**Option C: Stack Limit with Clear Errors**\n- Track recursion depth manually\n- Raise clear error when limit exceeded (not Python stack overflow)\n- Simplest but doesn't solve the problem, just makes it clearer\n\n**Option D: Hybrid**\n- Detect simple tail recursion patterns, optimize those\n- Fall back to depth tracking for complex cases\n- Balanced approach\n\n**Recommendation:** Start with Option D (hybrid) or Option B (trampolining) for reasonable complexity/benefit ratio.\n\n### 2. Implement Tail-Call Detection\n**File:** `vibeprolog/engine.py`\n\nAdd tail position detection during goal resolution:\n\n**Tail position definition:**\n- A goal is in tail position if it's the last goal in a clause body\n- In `(A, B)`, only B can be in tail position\n- In `(A ; B)`, both A and B can be in tail position\n- After a cut `!`, the following goal is in tail position\n\n**Algorithm:**\n```python\ndef is_tail_position(goal, remaining_goals, has_choice_points):\n    \"\"\"Check if goal is in tail position.\"\"\"\n    if remaining_goals:\n        return False  # Not last goal\n    if has_choice_points:\n        return False  # Other branches exist\n    return True\n```\n\n### 3. Implement TCO for Simple Cases\n**File:** `vibeprolog/engine.py`\n\nFor tail-recursive predicates, convert recursion to iteration:\n\n**Pattern to detect:**\n```prolog\ncount_down(0) :- !.\ncount_down(N) :- N > 0, N1 is N - 1, count_down(N1).\n```\n\n**Instead of:**\n```python\ndef resolve(goal):\n    # ...recursive call...\n    for result in resolve(new_goal):\n        yield result\n```\n\n**Do:**\n```python\ndef resolve(goal):\n    current_goal = goal\n    while True:\n        # ... resolve current_goal ...\n        if is_tail_call(next_goal):\n            current_goal = next_goal  # Loop instead of recurse\n            continue\n        else:\n            break\n```\n\n### 4. Implement Trampolining (Alternative)\n**File:** `vibeprolog/engine.py`\n\nIf choosing trampolining approach:\n\n**Return continuations:**\n```python\nclass Continuation:\n    def __init__(self, goal, subst, remaining):\n        self.goal = goal\n        self.subst = subst\n        self.remaining = remaining\n\ndef resolve_with_trampoline(goal, subst):\n    \"\"\"Resolve using trampolining.\"\"\"\n    stack = [Continuation(goal, subst, [])]\n    \n    while stack:\n        cont = stack.pop()\n        # Resolve cont.goal\n        # Instead of recursive call, push new Continuation\n        for result in resolve_one_step(cont.goal, cont.subst):\n            if has_subgoals(result):\n                stack.append(create_continuation(result))\n            else:\n                yield result\n```\n\n### 5. Add Depth Tracking\n**File:** `vibeprolog/engine.py`\n\nRegardless of TCO approach, add depth tracking:\n\n```python\nclass PrologEngine:\n    def __init__(self):\n        # ... existing init ...\n        self.max_depth = 10000  # Configurable\n        self.current_depth = 0\n        \n    def resolve(self, goal, subst, depth=0):\n        if depth > self.max_depth:\n            raise PrologThrow(\n                PrologError.resource_error(\n                    \"recursion_depth_exceeded\",\n                    f\"call/{len(goal.args) if hasattr(goal, 'args') else 0}\"\n                )\n            )\n        self.current_depth = max(self.current_depth, depth)\n        # ... resolution logic with depth+1 for recursive calls ...\n```\n\n### 6. Maintain Backtracking Correctness\n**Critical:** Ensure TCO doesn't break backtracking\n\n**Test cases:**\n```prolog\n% Should backtrack correctly\ngenerate(0, 0).\ngenerate(N, N) :- N > 0.\ngenerate(N, X) :- N > 0, N1 is N - 1, generate(N1, X).\n\n?- generate(3, X).\n% Should yield: X=3, X=2, X=1, X=0 (all solutions)\n```\n\n**Validation:**\n- TCO should only apply when no choice points remain\n- Preserve all solutions through backtracking\n- Cut semantics must remain correct\n\n### 7. Maintain Cut Semantics\n**Critical:** Ensure cuts work correctly with TCO\n\n**Test cases:**\n```prolog\nfirst_of(N, N) :- !.\nfirst_of(N, X) :- N > 0, N1 is N - 1, first_of(N1, X).\n\n?- first_of(5, X).\n% Should yield only X=5, not backtrack\n```\n\n### 8. Performance Benchmarking\n**File:** `tests/performance/test_recursion_performance.py`\n\nCreate benchmarks to measure impact:\n\n```python\nclass TestRecursionPerformance:\n    def test_deep_tail_recursion_speed(self):\n        prolog = PrologInterpreter()\n        prolog.consult_string(\"\"\"\n            count(0) :- !.\n            count(N) :- N > 0, N1 is N - 1, count(N1).\n        \"\"\")\n        start = time.time()\n        prolog.query_once(\"count(10000)\")\n        elapsed = time.time() - start\n        # Should complete in reasonable time\n        assert elapsed < 5.0  # seconds\n        \n    def test_non_tail_recursion_depth(self):\n        # Test that non-tail recursion either works or fails gracefully\n        pass\n```\n\n**Measure:**\n- Time to execute deep tail recursion (before/after)\n- Time to execute shallow recursion (regression check)\n- Memory usage\n- Maximum achievable depth\n\n### 9. Testing\n**File:** `tests/test_recursion.py`\n\nCreate comprehensive test coverage:\n\n**Deep tail recursion tests:**\n```python\nclass TestDeepTailRecursion:\n    def test_count_down_deep(self):\n        prolog = PrologInterpreter()\n        prolog.consult_string(\"\"\"\n            count_down(0) :- !.\n            count_down(N) :- N > 0, N1 is N - 1, count_down(N1).\n        \"\"\")\n        # Should not stack overflow\n        assert prolog.has_solution(\"count_down(10000)\")\n        \n    def test_tail_recursive_accumulator(self):\n        prolog = PrologInterpreter()\n        prolog.consult_string(\"\"\"\n            sum_to(N, Sum) :- sum_to(N, 0, Sum).\n            sum_to(0, Acc, Acc) :- !.\n            sum_to(N, Acc, Sum) :- \n                N > 0, \n                Acc1 is Acc + N, \n                N1 is N - 1, \n                sum_to(N1, Acc1, Sum).\n        \"\"\")\n        result = prolog.query_once(\"sum_to(100, X)\")\n        assert result['X'] == 5050\n```\n\n**Mutual recursion tests:**\n```python\nclass TestMutualRecursion:\n    def test_even_odd_deep(self):\n        prolog = PrologInterpreter()\n        prolog.consult_string(\"\"\"\n            even(0).\n            even(N) :- N > 0, N1 is N - 1, odd(N1).\n            odd(N) :- N > 0, N1 is N - 1, even(N1).\n        \"\"\")\n        assert prolog.has_solution(\"even(1000)\")\n```\n\n**Backtracking preservation tests:**\n```python\nclass TestBacktrackingWithTCO:\n    def test_all_solutions_preserved(self):\n        prolog = PrologInterpreter()\n        prolog.consult_string(\"\"\"\n            gen(0, 0).\n            gen(N, N) :- N > 0.\n            gen(N, X) :- N > 0, N1 is N - 1, gen(N1, X).\n        \"\"\")\n        results = list(prolog.query(\"gen(3, X)\"))\n        values = [r['X'] for r in results]\n        assert values == [3, 2, 1, 0]\n```\n\n**Cut interaction tests:**\n```python\nclass TestCutWithTCO:\n    def test_cut_stops_backtracking(self):\n        prolog = PrologInterpreter()\n        prolog.consult_string(\"\"\"\n            first(N, N) :- !.\n            first(N, X) :- N > 0, N1 is N - 1, first(N1, X).\n        \"\"\")\n        results = list(prolog.query(\"first(5, X)\"))\n        assert len(results) == 1\n        assert results[0]['X'] == 5\n```\n\n**Error handling tests:**\n```python\nclass TestRecursionLimits:\n    def test_depth_limit_error(self):\n        prolog = PrologInterpreter()\n        prolog.consult_string(\"\"\"\n            infinite :- infinite.\n        \"\"\")\n        # Should raise clear error, not Python stack overflow\n        with pytest.raises(Exception) as exc:\n            prolog.query_once(\"infinite\")\n        # Should be Prolog error, not Python RecursionError\n        assert \"recursion\" in str(exc.value).lower() or \"depth\" in str(exc.value).lower()\n```\n\n**Non-tail recursion tests:**\n```python\nclass TestNonTailRecursion:\n    def test_factorial_moderate_depth(self):\n        prolog = PrologInterpreter()\n        prolog.consult_string(\"\"\"\n            factorial(0, 1) :- !.\n            factorial(N, F) :- \n                N > 0, \n                N1 is N - 1, \n                factorial(N1, F1), \n                F is N * F1.\n        \"\"\")\n        # Non-tail recursive, should work to moderate depth\n        result = prolog.query_once(\"factorial(20, F)\")\n        assert result is not None\n```\n\n### 10. Documentation Updates\n**File:** `FEATURES.md`\n\nUpdate execution model section:\n```markdown\n## Execution Model\n- \u2705 Robinson-style unification\n- \u2705 Occurs check (prevents cyclic terms)\n- \u2705 Full backtracking search\n- \u2705 Dynamic clause enumeration\n- \u2705 Recursion handling\n- \u2705 Cut operator semantics\n- \u2705 Tail-call optimization (or: Recursion depth tracking)\n- \u2705 Deep recursion support (up to [depth] iterations for tail-recursive predicates)\n- \u26a0\ufe0f Non-tail recursion (limited to [depth] due to Python stack)\n```\n\n**File:** `ARCHITECTURE.md`\n\nAdd detailed TCO documentation:\n```markdown\n## Tail-Call Optimization\n\n### Approach\n[Document chosen approach: TCO, trampolining, depth tracking, or hybrid]\n\n### Tail Position Detection\n- A goal is in tail position when it's the last goal in a clause\n- [Detail the detection algorithm]\n\n### Optimization Strategy\n- [Describe how tail calls are converted to loops or trampolined]\n- [Explain choice point handling]\n- [Explain cut interaction]\n\n### Limitations\n- Tail-recursive predicates: supported to depth [X]\n- Non-tail-recursive predicates: supported to depth [Y]\n- Mutual recursion: [supported/limited/unsupported]\n- Maximum recursion depth: configurable, default [Z]\n\n### Performance Impact\n- Tail-recursive predicates: [performance characteristics]\n- Non-tail-recursive predicates: [performance impact]\n- Benchmark results: [summary]\n```\n\n### 11. Configuration\n**File:** `vibeprolog/interpreter.py`\n\nAdd configuration for recursion limits:\n\n```python\nclass PrologInterpreter:\n    def __init__(self, max_recursion_depth=10000):\n        self.max_recursion_depth = max_recursion_depth\n        # ... pass to engine ...\n```\n\nAllow users to configure the limit based on their needs.\n\n## Acceptance Criteria\n- Tail-recursive predicates can execute to deep depths without Python stack overflow\n- Non-tail-recursive predicates either work to reasonable depth OR fail with clear, informative error (not Python RecursionError)\n- Backtracking semantics remain correct (all solutions found)\n- Cut semantics remain correct (proper pruning)\n- Mutual recursion works correctly\n- Comprehensive test coverage in `tests/test_recursion.py` with all cases passing\n- Performance benchmarks show acceptable overhead\n- FEATURES.md documents execution model improvements with specific capabilities\n- ARCHITECTURE.md fully documents approach, algorithms, and limitations\n- Configuration option for recursion depth limits\n- Clear error messages when limits exceeded\n\n## Test Examples\n\nInclude these canonical examples in tests:\n\n```prolog\n% Tail-recursive count (should work to large N)\ncount_down(0) :- !.\ncount_down(N) :- N > 0, N1 is N - 1, count_down(N1).\n\n% Tail-recursive with accumulator\nsum_to(N, Sum) :- sum_to(N, 0, Sum).\nsum_to(0, Acc, Acc) :- !.\nsum_to(N, Acc, Sum) :- N > 0, Acc1 is Acc + N, N1 is N - 1, sum_to(N1, Acc1, Sum).\n\n% Mutual tail recursion\neven(0).\neven(N) :- N > 0, N1 is N - 1, odd(N1).\nodd(N) :- N > 0, N1 is N - 1, even(N1).\n\n% Backtracking with recursion\ngenerate(0, 0).\ngenerate(N, N) :- N > 0.\ngenerate(N, X) :- N > 0, N1 is N - 1, generate(N1, X).\n\n% Cut with tail recursion\nfirst_of(N, N) :- !.\nfirst_of(N, X) :- N > 0, N1 is N - 1, first_of(N1, X).\n\n% Non-tail recursion (for comparison)\nfactorial(0, 1) :- !.\nfactorial(N, F) :- N > 0, N1 is N - 1, factorial(N1, F1), F is N * F1.\n```\n\n## References\n- SWI-Prolog WAM implementation with last-call optimization\n- Trampolining in Python: https://en.wikipedia.org/wiki/Trampoline_(computing)\n- Tail call optimization techniques",
      "comments": [
        {
          "id": 3591672531,
          "author": "nlothian",
          "body": "Note that #153 enforces a recursion depth limit",
          "created_at": "2025-11-29T13:16:14Z",
          "updated_at": "2025-11-29T13:16:14Z",
          "url": "https://github.com/nlothian/Vibe-Prolog/issues/141#issuecomment-3591672531"
        }
      ],
      "labels": [],
      "milestones": [],
      "linked_branches": []
    },
    {
      "number": 7,
      "title": "Compatibility: Mirror SWI-Prolog examples",
      "url": "https://github.com/nlothian/Vibe-Prolog/issues/7",
      "parent": null,
      "blocked_by": [
        {
          "number": 75,
          "title": "Implement command-line argument support (argv)",
          "url": "https://github.com/nlothian/Vibe-Prolog/issues/75",
          "blocking_issue_status": "closed"
        }
      ],
      "blocking": [],
      "description": "## Overview\n\nThis task is about **validating that our Prolog interpreter behaves the same way as SWI-Prolog**, which is one of the most popular Prolog implementations. We want to ensure our syntax and behavior match what developers expect from widely-used Prolog systems.\n\n## Why This Matters\n\n- **Compatibility**: Users should be able to run standard Prolog examples on our interpreter\n- **Confidence**: Automated tests comparing our output to SWI-Prolog give us confidence we're implementing Prolog correctly\n- **Documentation**: This helps identify what features we're missing or where we deviate from standard behavior\n\n## Prerequisites\n\n1. **Install SWI-Prolog** on your system:\n   - Mac: `brew install swi-prolog`\n   - Linux: `apt-get install swi-prolog` or `yum install swi-prolog`\n   - Windows: Download from https://www.swi-prolog.org/Download.html\n\n2. **Verify installation**:\n   ```bash\n   swipl --version\n   ```\n\n3. **Understand our test structure** (see `AGENTS.md` for details):\n   - All tests go in `tests/` directory\n   - Test files are named `test_*.py`\n   - Use pytest framework with test classes\n   - Import with `from prolog import PrologInterpreter`\n\n## Step-by-Step Instructions\n\n### Step 1: Find Representative SWI-Prolog Examples\n\nLook for examples in these categories (prioritize ones testing features marked \u2705 in `FEATURES.md`):\n\n**Control Flow Examples:**\n- Conjunction (`,`), disjunction (`;`), if-then-else (`->`)\n- Negation (`\\+`), cut (`!`)\n- Backtracking behavior\n\n**Arithmetic Examples:**\n- Arithmetic evaluation (`is/2`)\n- Arithmetic comparison (`=:=`, `<`, `>`, etc.)\n- Complex expressions with operators (`+`, `-`, `*`, `/`, `mod`, `**`)\n\n**Data Structure Examples:**\n- List manipulation (`append/3`, `member/2`, `length/2`, `reverse/2`)\n- Compound terms (`functor/3`, `arg/3`, `=../2`)\n- Type testing (`var/1`, `atom/1`, `number/1`, etc.)\n\n**Good sources for examples:**\n- [SWI-Prolog documentation](https://www.swi-prolog.org/pldoc/man?section=builtin)\n- [Learn Prolog Now!](http://www.learnprolognow.org/)\n- SWI-Prolog's own test suite\n\n### Step 2: Test Examples in SWI-Prolog\n\nBefore porting, verify the example works in SWI-Prolog:\n\n```bash\n# Start SWI-Prolog\nswipl\n\n# Test a query\n?- append([1,2], [3,4], X).\nX = [1, 2, 3, 4].\n\n# Test with backtracking\n?- member(X, [1,2,3]).\nX = 1 ;\nX = 2 ;\nX = 3.\n```\n\n**Document the expected behavior** - write down:\n- What query you ran\n- What solutions you got\n- Whether it backtracks (provides multiple solutions)\n- Any error messages\n\n### Step 3: Create Test Cases\n\nCreate a new test file or add to an existing one. Follow this pattern:\n\n```python\n\"\"\"Tests comparing behavior to SWI-Prolog examples.\"\"\"\n\nimport pytest\nfrom prolog import PrologInterpreter\n\n\nclass TestSWIPrologControlFlow:\n    \"\"\"Tests based on SWI-Prolog control flow examples.\"\"\"\n    \n    def test_conjunction_example(self):\n        \"\"\"\n        SWI-Prolog example from: [URL or book reference]\n        Query: X = 1, Y = 2.\n        Expected: X = 1, Y = 2\n        \"\"\"\n        prolog = PrologInterpreter()\n        result = prolog.query_once(\"X = 1, Y = 2\")\n        assert result is not None\n        assert result['X'] == 1\n        assert result['Y'] == 2\n    \n    def test_backtracking_example(self):\n        \"\"\"\n        SWI-Prolog example: member/2 with backtracking\n        Query: member(X, [a,b,c]).\n        Expected: X = a ; X = b ; X = c\n        \"\"\"\n        prolog = PrologInterpreter()\n        results = list(prolog.query(\"member(X, [a, b, c])\"))\n        assert len(results) == 3\n        assert results[0]['X'] == 'a'\n        assert results[1]['X'] == 'b'\n        assert results[2]['X'] == 'c'\n\n\nclass TestSWIPrologArithmetic:\n    \"\"\"Tests based on SWI-Prolog arithmetic examples.\"\"\"\n    \n    def test_arithmetic_expression(self):\n        \"\"\"\n        SWI-Prolog example: X is 2 + 3 * 4.\n        Expected: X = 14 (multiplication before addition)\n        \"\"\"\n        prolog = PrologInterpreter()\n        result = prolog.query_once(\"X is 2 + 3 * 4\")\n        assert result is not None\n        assert result['X'] == 14\n```\n\n### Step 4: Run Tests and Compare\n\n```bash\n# Run your new tests\nuv run pytest tests/test_swi_examples.py -v\n\n# Run all tests to make sure nothing broke\nuv run pytest\n```\n\n### Step 5: Document Incompatibilities\n\nIf you find differences between our interpreter and SWI-Prolog:\n\n1. **Add a comment in your test** explaining the deviation:\n   ```python\n   @pytest.mark.skip(reason=\"Feature not implemented: read/1\")\n   def test_read_term(self):\n       \"\"\"SWI-Prolog supports read/1 but we don't implement it yet.\"\"\"\n       pass\n   ```\n\n2. **Update FEATURES.md** if you discover missing features or incorrect implementations\n\n3. **Create follow-up issues** for significant problems:\n   ```bash\n   gh issue create --title \"Fix: append/3 fails with improper lists\" \\\n       --body \"Found in SWI-Prolog compatibility testing. Expected behavior: ...\"\n   ```\n\n## Example Test File Structure\n\nLook at existing test files for patterns to follow:\n- `tests/test_iso_core.py` - Well-organized ISO standard tests\n- `tests/test_builtins.py` - Tests for built-in predicates\n- `tests/test_arithmetic.py` - Arithmetic operation tests\n\n## Testing Checklist\n\n- [ ] Selected 10-15 representative examples from SWI-Prolog\n- [ ] Verified each example works in SWI-Prolog (document expected output)\n- [ ] Created test file(s) in `tests/` directory following pytest conventions\n- [ ] Each test has a docstring explaining the SWI-Prolog source\n- [ ] Tests cover control flow, arithmetic, and data structures\n- [ ] All tests pass (or marked with `@pytest.mark.skip` with reason)\n- [ ] Documented any incompatibilities in test comments\n- [ ] Updated `FEATURES.md` if you found missing/incorrect features\n- [ ] Created follow-up issues for bugs or missing features found\n\n## Questions?\n\n- Review existing test files in `tests/` directory for examples\n- Check `AGENTS.md` for development workflow guidelines\n- Check `FEATURES.md` to see what's already implemented\n- Ask for help if you're unsure about expected behavior\n\n## Success Criteria\n\n- At least 10 new tests comparing our behavior to SWI-Prolog\n- Tests cover multiple categories (control, arithmetic, data structures)\n- Any incompatibilities are documented\n- All tests either pass or are marked with clear skip reasons\n- `FEATURES.md` updated if new gaps discovered",
      "comments": [],
      "labels": [],
      "milestones": [],
      "linked_branches": []
    }
  ]
}